[
  {
    "problem_id": "Q001",
    "metadata": {
      "week": 1,
      "day": 1,
      "topic": "Input/Output",
      "title": "Welcome to Coding",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "TCS",
        "Infosys"
      ],
      "learning_outcomes": [
        "Basic Syntax",
        "Output Formatting"
      ]
    },
    "problem_statement": {
      "description": "Write a program that prints 'Welcome to the World of Coding' to the standard output.",
      "constraints": [
        "None"
      ],
      "input_format": "No input is required.",
      "output_format": "Print the exact string: Welcome to the World of Coding",
      "example": {
        "input": "",
        "output": "Welcome to the World of Coding",
        "explanation": "The program simply prints the welcome message."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "",
        "expected_output": "Welcome to the World of Coding",
        "explanation": "Standard output check.",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "Any Input",
        "expected_output": "Welcome to the World of Coding",
        "explanation": "Ignores input.",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use the print function of your language.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Ensure exact spelling and capitalization.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "No newline is strictly required unless specified, but standard print adds one.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "This is the simplest program possible.",
        "hint_type": "conceptual"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Direct print statement."
    }
  },
  {
    "problem_id": "Q002",
    "metadata": {
      "week": 1,
      "day": 1,
      "topic": "Variables",
      "title": "Sum of Two Integers",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Wipro",
        "HCL"
      ],
      "learning_outcomes": [
        "Input Parsing",
        "Arithmetic Operations"
      ]
    },
    "problem_statement": {
      "description": "Write a program that takes two integers as input and prints their sum.",
      "constraints": [
        "-10^9 <= A, B <= 10^9"
      ],
      "input_format": "Two space-separated integers A and B.",
      "output_format": "Print the sum of A and B.",
      "example": {
        "input": "10 20",
        "output": "30",
        "explanation": "10 + 20 = 30"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 7",
        "expected_output": "12",
        "explanation": "5 + 7 = 12",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "-5 -10",
        "expected_output": "-15",
        "explanation": "Negative numbers",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1000000000 1000000000",
        "expected_output": "2000000000",
        "explanation": "Large numbers within int range",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Read the two integers from input.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use the + operator.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Ensure you handle negative numbers correctly.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Check if your language uses 32-bit or 64-bit integers implicitly.",
        "hint_type": "interview"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Direct addition."
    }
  },
  {
    "problem_id": "Q003",
    "metadata": {
      "week": 1,
      "day": 1,
      "topic": "Variables",
      "title": "Swap Two Numbers",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Accenture"
      ],
      "learning_outcomes": [
        "Variable Assignment",
        "Logic Building"
      ]
    },
    "problem_statement": {
      "description": "Write a program to swap two numbers provided as input.",
      "constraints": [
        "-1000 <= A, B <= 1000"
      ],
      "input_format": "Two space-separated integers A and B.",
      "output_format": "Print the swapped values separated by a space.",
      "example": {
        "input": "2 3",
        "output": "3 2",
        "explanation": "A becomes 3, B becomes 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 10",
        "expected_output": "10 5",
        "explanation": "Normal swap",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "-1 1",
        "expected_output": "1 -1",
        "explanation": "Swap with negative",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0 0",
        "expected_output": "0 0",
        "explanation": "Same numbers",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "You can use a temporary variable.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "temp = a; a = b; b = temp;",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Can you do it without a temporary variable? (XOR or Addition)",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Be careful with overflow if using Addition method.",
        "hint_type": "trade_off"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Using temp variable is standard, XOR is a trick."
    }
  },
  {
    "problem_id": "Q004",
    "metadata": {
      "week": 1,
      "day": 1,
      "topic": "Operators",
      "title": "Area of Rectangle",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Arithmetic",
        "Formula Implementation"
      ]
    },
    "problem_statement": {
      "description": "Calculate the area of a rectangle given its length and width.",
      "constraints": [
        "1 <= L, W <= 1000"
      ],
      "input_format": "Two positive integers L and W.",
      "output_format": "Print the area.",
      "example": {
        "input": "5 4",
        "output": "20",
        "explanation": "5 * 4 = 20"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "10 5",
        "expected_output": "50",
        "explanation": "10 * 5 = 50",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 1",
        "expected_output": "1",
        "explanation": "Smallest inputs",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1000 1000",
        "expected_output": "1000000",
        "explanation": "Largest inputs",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Area = Length * Width",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Ensure you output just the number.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "Inputs are guaranteed positive.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Check variable type size for result (int is sufficient here).",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Multiply and print."
    }
  },
  {
    "problem_id": "Q005",
    "metadata": {
      "week": 1,
      "day": 1,
      "topic": "Data Types",
      "title": "Float Precision",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Cognizant"
      ],
      "learning_outcomes": [
        "Floating Point",
        "Formatting"
      ]
    },
    "problem_statement": {
      "description": "Write a program that takes two floating point numbers, divides the first by the second, and prints the result rounded to 2 decimal places.",
      "constraints": [
        "-1000.0 <= A, B <= 1000.0",
        "B != 0"
      ],
      "input_format": "Two numbers A and B.",
      "output_format": "Result formatted to 2 decimal places.",
      "example": {
        "input": "5.0 2.0",
        "output": "2.50",
        "explanation": "5/2 = 2.5, formatted to 2.50"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "10.0 3.0",
        "expected_output": "3.33",
        "explanation": "Repeating decimal",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "4.0 2.0",
        "expected_output": "2.00",
        "explanation": "Exact division",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1.0 0.005",
        "expected_output": "200.00",
        "explanation": "Division by small number",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use float or double types.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Look for formatted print functions like printf or format().",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "B will not be zero per constraints.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Standard rounding rules apply.",
        "hint_type": "conceptual"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Division and formatting."
    }
  },
  {
    "problem_id": "Q006",
    "metadata": {
      "week": 1,
      "day": 2,
      "topic": "Conditionals",
      "title": "Even or Odd",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Modulus Operator",
        "If-Else"
      ]
    },
    "problem_statement": {
      "description": "Check if a given integer is even or odd.",
      "constraints": [
        "-10^9 <= N <= 10^9"
      ],
      "input_format": "An integer N.",
      "output_format": "Print 'Even' if even, 'Odd' if odd.",
      "example": {
        "input": "5",
        "output": "Odd",
        "explanation": "5 is not divisible by 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2",
        "expected_output": "Even",
        "explanation": "2 divisible by 2",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "Even",
        "explanation": "0 is even",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "-3",
        "expected_output": "Odd",
        "explanation": "Negative odd number",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use the modulus operator %.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "N % 2 == 0 means even.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Be careful, negative numbers % 2 might return -1 in some languages.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Bitwise AND (N & 1) is an optimization.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "N % 2 or N & 1."
    }
  },
  {
    "problem_id": "Q007",
    "metadata": {
      "week": 1,
      "day": 2,
      "topic": "Conditionals",
      "title": "Largest of Three Numbers",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Capgemini"
      ],
      "learning_outcomes": [
        "Logical Operators",
        "Comparison"
      ]
    },
    "problem_statement": {
      "description": "Find the largest among three distinct numbers entered by the user.",
      "constraints": [
        "-1000 <= A, B, C <= 1000"
      ],
      "input_format": "Three space-separated integers.",
      "output_format": "Print the largest number.",
      "example": {
        "input": "1 5 3",
        "output": "5",
        "explanation": "5 is greater than 1 and 3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "10 20 30",
        "expected_output": "30",
        "explanation": "C is largest",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "50 20 10",
        "expected_output": "50",
        "explanation": "A is largest",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "-10 -20 -5",
        "expected_output": "-5",
        "explanation": "Negative numbers",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Compare A vs B first, then the winner vs C.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Use logical AND (&&) to combine conditions.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If A > B and A > C, then A is largest.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Consider if numbers can be equal (input says distinct, but good to handle).",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Comparison logic."
    }
  },
  {
    "problem_id": "Q008",
    "metadata": {
      "week": 1,
      "day": 2,
      "topic": "Conditionals",
      "title": "Grade Calculator",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Infosys"
      ],
      "learning_outcomes": [
        "Else-If Ladder",
        "Ranges"
      ]
    },
    "problem_statement": {
      "description": "Write a program to assign grades based on marks. 90-100: A, 80-89: B, 70-79: C, 60-69: D, <60: F.",
      "constraints": [
        "0 <= Marks <= 100"
      ],
      "input_format": "An integer representing Marks.",
      "output_format": "Print the Grade Character.",
      "example": {
        "input": "85",
        "output": "B",
        "explanation": "85 is in 80-89 range."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "95",
        "expected_output": "A",
        "explanation": ">= 90",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "59",
        "expected_output": "F",
        "explanation": "< 60",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "70",
        "expected_output": "C",
        "explanation": "Boundary checking",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Check ranges from top to bottom.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Use if-else if structure.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Ensure you handle boundary values (e.g., exactly 90) correctly.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Marks will always be between 0 and 100.",
        "hint_type": "conceptual"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Ladder if-else."
    }
  },
  {
    "problem_id": "Q009",
    "metadata": {
      "week": 1,
      "day": 2,
      "topic": "Conditionals",
      "title": "Leap Year",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "TCS",
        "Accenture"
      ],
      "learning_outcomes": [
        "Complex Logic",
        "Modulo"
      ]
    },
    "problem_statement": {
      "description": "Determine whether a given year is a leap year. A year is leap if divisible by 4, unless divisible by 100 but not 400.",
      "constraints": [
        "1000 <= Year <= 9999"
      ],
      "input_format": "An integer Year.",
      "output_format": "Print 'Yes' if leap, 'No' otherwise.",
      "example": {
        "input": "2000",
        "output": "Yes",
        "explanation": "Divisible by 400."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2024",
        "expected_output": "Yes",
        "explanation": "Divisible by 4, not 100",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2100",
        "expected_output": "No",
        "explanation": "Divisible by 100, not 400",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2000",
        "expected_output": "Yes",
        "explanation": "Divisible by 400",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Leap year logic: divisible by 4 AND (not divisible by 100 OR divisible by 400).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 2,
        "hint_text": "Order of checks matters.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Year % 4 == 0 is the primary condition.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 4,
        "hint_text": "Pay attention to centuries (1900, 2100 are not leap years, 2000 is).",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "One combined boolean expression."
    }
  },
  {
    "problem_id": "Q010",
    "metadata": {
      "week": 1,
      "day": 2,
      "topic": "Switch Case",
      "title": "Simple Calculator",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Switch Case",
        "Input Handling"
      ]
    },
    "problem_statement": {
      "description": "Implement a simple calculator that performs +, -, *, or / based on operator input.",
      "constraints": [
        "-1000 <= A, B <= 1000",
        "Operator in {+, -, *, /}"
      ],
      "input_format": "Space separated: A Operator B",
      "output_format": "Result of the operation.",
      "example": {
        "input": "10 + 5",
        "output": "15",
        "explanation": "Addition performed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "10 * 5",
        "expected_output": "50",
        "explanation": "Multiplication",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "10 / 2",
        "expected_output": "5",
        "explanation": "Division",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "5 - 10",
        "expected_output": "-5",
        "explanation": "Subtraction",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use a switch-case or if-else ladder on the operator character.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "For division, assume integer division unless floating point is specified (here standard example implies integer).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "Watch out for division by zero logic, though constraints say A,B are integers, usually assume valid input unless specified.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Parse the operator carefully as a character or string.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Switch statement."
    }
  },
  {
    "problem_id": "Q011",
    "metadata": {
      "week": 1,
      "day": 3,
      "topic": "Loops",
      "title": "Print 1 to N",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Looping",
        "Counters"
      ]
    },
    "problem_statement": {
      "description": "Write a program that prints numbers from 1 to N, each on a new line.",
      "constraints": [
        "1 <= N <= 1000"
      ],
      "input_format": "A single integer N.",
      "output_format": "Integers from 1 to N on separate lines.",
      "example": {
        "input": "5",
        "output": "1\n2\n3\n4\n5",
        "explanation": "Numbers 1 to 5 printed sequentially."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3",
        "expected_output": "1\n2\n3",
        "explanation": "Basic loop",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single iteration",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "10",
        "expected_output": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
        "explanation": "Loop to 10",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use a for loop or while loop.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Start index from 1, condition <= N.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Don't forget to increment your counter.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Ensure newlines are printed correctly.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Single loop traversal."
    }
  },
  {
    "problem_id": "Q012",
    "metadata": {
      "week": 1,
      "day": 3,
      "topic": "Loops",
      "title": "Sum of First N Natural Numbers",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "TCS"
      ],
      "learning_outcomes": [
        "Accumulator",
        "Loop vs Formula"
      ]
    },
    "problem_statement": {
      "description": "Calculate the sum of the first N natural numbers (1 + 2 + ... + N).",
      "constraints": [
        "1 <= N <= 10000"
      ],
      "input_format": "An integer N.",
      "output_format": "Print the sum.",
      "example": {
        "input": "5",
        "output": "15",
        "explanation": "1+2+3+4+5 = 15"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "10",
        "expected_output": "55",
        "explanation": "Sum of 1-10",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "Smallest N",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "100",
        "expected_output": "5050",
        "explanation": "Larger N",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Initialize a sum variable to 0.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Loop from 1 to N adding to sum.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Can you do it without a loop? Formula N*(N+1)/2.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Formula is O(1) time complexity.",
        "hint_type": "trade_off"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N) with loop, O(1) with formula",
      "space_complexity": "O(1)",
      "optimal_approach": "Mathematical formula N*(N+1)/2"
    }
  },
  {
    "problem_id": "Q013",
    "metadata": {
      "week": 1,
      "day": 3,
      "topic": "Loops",
      "title": "Factorial of N",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Wipro",
        "Infosys"
      ],
      "learning_outcomes": [
        "Loops",
        "Multiplication Logic"
      ]
    },
    "problem_statement": {
      "description": "Calculate the factorial of a given number N. Factorial of N (N!) is the product of all positive integers less than or equal to N. 0! = 1.",
      "constraints": [
        "0 <= N <= 20",
        "Use appropriate data type for result."
      ],
      "input_format": "An integer N.",
      "output_format": "Print the factorial.",
      "example": {
        "input": "5",
        "output": "120",
        "explanation": "5*4*3*2*1 = 120"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3",
        "expected_output": "6",
        "explanation": "3*2*1=6",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "1",
        "explanation": "0! is 1",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "20",
        "expected_output": "2432902008176640000",
        "explanation": "Large factorial requires Long",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Initialize result to 1, not 0.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Loop from 1 to N multiplying result.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Handle N=0 case explicitly or standard loop logic covers it (1 to 0 never runs, result stays 1).",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "N=20 exceeds standard 32-bit integer range. Use Long.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Iterative approach."
    }
  },
  {
    "problem_id": "Q014",
    "metadata": {
      "week": 1,
      "day": 3,
      "topic": "Loops",
      "title": "Fibonacci Series",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "TCS",
        "Accenture"
      ],
      "learning_outcomes": [
        "Series Generation",
        "Swapping logic"
      ]
    },
    "problem_statement": {
      "description": "Print the first N terms of the Fibonacci series. 0, 1, 1, 2, 3, 5...",
      "constraints": [
        "1 <= N <= 30"
      ],
      "input_format": "An integer N.",
      "output_format": "Space separated integers.",
      "example": {
        "input": "5",
        "output": "0 1 1 2 3",
        "explanation": "First 5 terms."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2",
        "expected_output": "0 1",
        "explanation": "Basic case",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "0",
        "explanation": "Edge case",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "7",
        "expected_output": "0 1 1 2 3 5 8",
        "explanation": "Series logic",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "First term 0, second term 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Next term = prev + current.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Use two variables to track previous terms.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Print as you generate.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Iterative generation."
    }
  },
  {
    "problem_id": "Q015",
    "metadata": {
      "week": 1,
      "day": 3,
      "topic": "Patterns",
      "title": "Right Triangle Star Pattern",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Nested Loops"
      ]
    },
    "problem_statement": {
      "description": "Print a right-angled triangle pattern of stars of height N.",
      "constraints": [
        "1 <= N <= 20"
      ],
      "input_format": "Integer N.",
      "output_format": "Pattern output.",
      "example": {
        "input": "3",
        "output": "*\n**\n***",
        "explanation": "Row 1: 1 star, Row 2: 2 stars, Row 3: 3 stars."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2",
        "expected_output": "*\n**",
        "explanation": "Height 2",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "*",
        "explanation": "Height 1",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4",
        "expected_output": "*\n**\n***\n****",
        "explanation": "Height 4",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use nested loops.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Outer loop controls rows (i from 1 to N).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Inner loop controls stars (j from 1 to i).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Print newline after inner loop.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(1)",
      "optimal_approach": "Nested loops."
    }
  },
  {
    "problem_id": "Q016",
    "metadata": {
      "week": 1,
      "day": 4,
      "topic": "Arrays",
      "title": "Sum of Array Elements",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Array Traversal"
      ]
    },
    "problem_statement": {
      "description": "Calculate the sum of all elements in an integer array.",
      "constraints": [
        "1 <= Size <= 1000",
        "-1000 <= Elements <= 1000"
      ],
      "input_format": "First line: N (size). Second line: N space-separated integers.",
      "output_format": "Print the sum.",
      "example": {
        "input": "5\n1 2 3 4 5",
        "output": "15",
        "explanation": "Sum is 15."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n10 20 30",
        "expected_output": "60",
        "explanation": "Sum is 60",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n5",
        "expected_output": "5",
        "explanation": "Single element",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3\n-1 -2 -3",
        "expected_output": "-6",
        "explanation": "Negative numbers",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Initialize sum to 0.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterate through the array.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Add each element to sum.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Use long long if sum can exceed integer limit (here constraints allow int).",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Linear traversal."
    }
  },
  {
    "problem_id": "Q017",
    "metadata": {
      "week": 1,
      "day": 4,
      "topic": "Arrays",
      "title": "Find Maximum Element",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "TCS"
      ],
      "learning_outcomes": [
        "Min/Max Algorithm"
      ]
    },
    "problem_statement": {
      "description": "Find the maximum element in an array.",
      "constraints": [
        "1 <= N <= 1000",
        "-10^6 <= Elements <= 10^6"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "The maximum integer.",
      "example": {
        "input": "5\n1 5 3 9 2",
        "output": "9",
        "explanation": "9 is the largest."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n1 2 3",
        "expected_output": "3",
        "explanation": "Sorted order",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "3\n-1 -5 -2",
        "expected_output": "-1",
        "explanation": "Negatives",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4\n10 10 10 10",
        "expected_output": "10",
        "explanation": "All equal",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Assume first element is max initially.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Compare each subsequent element with current max.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Update max if current element is larger.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Do not initialize max to 0 if inputs can be negative.",
        "hint_type": "common_mistake"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Linear scan."
    }
  },
  {
    "problem_id": "Q018",
    "metadata": {
      "week": 1,
      "day": 4,
      "topic": "Arrays",
      "title": "Count Occurrences",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Linear Search"
      ]
    },
    "problem_statement": {
      "description": "Count how many times a target number K appears in an array.",
      "constraints": [
        "1 <= N <= 1000",
        "Elements and K in integer range"
      ],
      "input_format": "N, K, then N integers.",
      "output_format": "The count of K.",
      "example": {
        "input": "5 2\n1 2 3 2 4",
        "output": "2",
        "explanation": "2 appears twice."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4 1\n1 1 1 1",
        "expected_output": "4",
        "explanation": "All match",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "3 5\n1 2 3",
        "expected_output": "0",
        "explanation": "No match",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1 10\n10",
        "expected_output": "1",
        "explanation": "Single match",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Initialize count to 0.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Traverse the array.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If element == K, increment count.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Return final count.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Linear search."
    }
  },
  {
    "problem_id": "Q019",
    "metadata": {
      "week": 1,
      "day": 4,
      "topic": "Arrays",
      "title": "Check if Array is Sorted",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Accenture"
      ],
      "learning_outcomes": [
        "Array Properties",
        "Logic"
      ]
    },
    "problem_statement": {
      "description": "Check if an array is sorted in non-decreasing order.",
      "constraints": [
        "1 <= N <= 1000"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Print 'Yes' or 'No'.",
      "example": {
        "input": "4\n1 2 3 4",
        "output": "Yes",
        "explanation": "Strictly increasing."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n1 3 2",
        "expected_output": "No",
        "explanation": "3 > 2, unsorted",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n5",
        "expected_output": "Yes",
        "explanation": "Single element is always sorted",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4\n1 1 2 2",
        "expected_output": "Yes",
        "explanation": "Non-decreasing includes equals",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "You need to compare adjacent elements.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "If you find any pair where arr[i] > arr[i+1], it's not sorted.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Loop from 0 to N-2.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "If loop finishes without finding such pair, it is sorted.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "One pass."
    }
  },
  {
    "problem_id": "Q020",
    "metadata": {
      "week": 1,
      "day": 4,
      "topic": "Arrays",
      "title": "Reverse an Array",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "GlobalLogic"
      ],
      "learning_outcomes": [
        "Two Pointer"
      ]
    },
    "problem_statement": {
      "description": "Reverse an array in-place (or print it in reverse order).",
      "constraints": [
        "1 <= N <= 1000"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Space separated reversed array.",
      "example": {
        "input": "3\n1 2 3",
        "output": "3 2 1",
        "explanation": "Reversed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4\n10 20 5 8",
        "expected_output": "8 5 20 10",
        "explanation": "Reversed",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n5",
        "expected_output": "5",
        "explanation": "Single element",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2\n1 2",
        "expected_output": "2 1",
        "explanation": "Two elements",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "You can print from last index to first.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Or swap first and last, second and second-last.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Use two pointers, start=0, end=N-1.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "While start < end, swap and move pointers inward.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1) auxiliary",
      "optimal_approach": "Two pointer swap."
    }
  },
  {
    "problem_id": "Q021",
    "metadata": {
      "week": 1,
      "day": 5,
      "topic": "Functions",
      "title": "Function to Add Two Numbers",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Modular Code",
        "Return Values"
      ]
    },
    "problem_statement": {
      "description": "Create a function `add(a, b)` that returns the sum of two integers.",
      "constraints": [
        "-1000 <= A, B <= 1000"
      ],
      "input_format": "Two integers A and B.",
      "output_format": "Print the result returned by the function.",
      "example": {
        "input": "10 20",
        "output": "30",
        "explanation": "Function returns 30."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 7",
        "expected_output": "12",
        "explanation": "Basic addition",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0 0",
        "expected_output": "0",
        "explanation": "Zeroes",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "-5 5",
        "expected_output": "0",
        "explanation": "Negative + Positive",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Define a function with two parameters.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Return a + b inside the function.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Call the function from main and print result.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Ensure function signature matches requirement (though in this environment structure matters most).",
        "hint_type": "interview"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Return a+b."
    }
  },
  {
    "problem_id": "Q022",
    "metadata": {
      "week": 1,
      "day": 5,
      "topic": "Recursion",
      "title": "Recursive Factorial",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "TCS",
        "Wipro"
      ],
      "learning_outcomes": [
        "Recursion Basics",
        "Base Case"
      ]
    },
    "problem_statement": {
      "description": "Calculate factorial of N using recursion.",
      "constraints": [
        "0 <= N <= 12 (to fit in int)"
      ],
      "input_format": "Integer N.",
      "output_format": "Factorial of N.",
      "example": {
        "input": "5",
        "output": "120",
        "explanation": "5*4*3*2*1"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5",
        "expected_output": "120",
        "explanation": "Standard case",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "1",
        "explanation": "Base case 0! = 1",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1",
        "expected_output": "1",
        "explanation": "Base case 1! = 1",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Base case: if N <= 1 return 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Recursive step: return N * factorial(N-1).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Ensure function calls itself.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Watch for stack overflow if N is too large (recursion depth).",
        "hint_type": "trade_off"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N) stack space",
      "optimal_approach": "Recursive solution."
    }
  },
  {
    "problem_id": "Q023",
    "metadata": {
      "week": 1,
      "day": 5,
      "topic": "Recursion",
      "title": "Nth Fibonacci Number",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Basic"
      ],
      "learning_outcomes": [
        "Recursion",
        "Tree Recursion"
      ]
    },
    "problem_statement": {
      "description": "Find the Nth Fibonacci number using recursion. (0th is 0, 1st is 1).",
      "constraints": [
        "0 <= N <= 30"
      ],
      "input_format": "Integer N.",
      "output_format": "Nth Fibonacci number.",
      "example": {
        "input": "6",
        "output": "8",
        "explanation": "0, 1, 1, 2, 3, 5, 8 (6th index)"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5",
        "expected_output": "5",
        "explanation": "5th term",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "0",
        "explanation": "0th term",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "10",
        "expected_output": "55",
        "explanation": "10th term",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Base cases: if N=0 return 0, if N=1 return 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Recursive step: fib(N) = fib(N-1) + fib(N-2).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "This is naive recursion, very slow for large N.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 4,
        "hint_text": "Time complexity is exponential O(2^N).",
        "hint_type": "interview"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(2^N)",
      "space_complexity": "O(N) stack",
      "optimal_approach": "Recursive for learning, DP for efficiency."
    }
  },
  {
    "problem_id": "Q024",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Recursion",
      "title": "Power Function",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Microsoft"
      ],
      "learning_outcomes": [
        "Recursion",
        "Math"
      ]
    },
    "problem_statement": {
      "description": "Calculate X raised to the power N (X^N) using recursion.",
      "constraints": [
        "1 <= X <= 10",
        "0 <= N <= 10"
      ],
      "input_format": "Integers X and N.",
      "output_format": "Result of X^N.",
      "example": {
        "input": "2 3",
        "output": "8",
        "explanation": "2*2*2 = 8"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 2",
        "expected_output": "25",
        "explanation": "5^2",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "10 0",
        "expected_output": "1",
        "explanation": "Power 0 is 1",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2 10",
        "expected_output": "1024",
        "explanation": "Larger power",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Base case: N=0 return 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Recurrence: X * power(X, N-1).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Can you optimize to O(log N)? power(X, N/2).",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "If optimized, handle odd N by multiplying extra X.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N) linear, O(log N) optimized",
      "space_complexity": "O(N) or O(log N)",
      "optimal_approach": "Binary Exponentiation."
    }
  },
  {
    "problem_id": "Q025",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Logic",
      "title": "Palindrome Number",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic",
        "TCS"
      ],
      "learning_outcomes": [
        "Digit Extraction",
        "Reversal"
      ]
    },
    "problem_statement": {
      "description": "Check if a given integer is a palindrome (reads same forwards and backwards).",
      "constraints": [
        "0 <= N <= 10^9"
      ],
      "input_format": "Integer N.",
      "output_format": "Print 'Yes' or 'No'.",
      "example": {
        "input": "121",
        "output": "Yes",
        "explanation": "121 reversed is 121."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "123",
        "expected_output": "No",
        "explanation": "Reversed is 321",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "7",
        "expected_output": "Yes",
        "explanation": "Single digit is palindrome",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1221",
        "expected_output": "Yes",
        "explanation": "Even length palindrome",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Extract digits one by one using % 10.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Build the reversed number: rev = rev * 10 + digit.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Compare original N with reversed N.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Store original N in a temp variable before modifying it in loop.",
        "hint_type": "common_mistake"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log N) (number of digits)",
      "space_complexity": "O(1)",
      "optimal_approach": "Digit reversal."
    }
  },
  {
    "problem_id": "Q026",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Math",
      "title": "GCD of Two Numbers",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Goldman Sachs"
      ],
      "learning_outcomes": [
        "Euclidean Algorithm"
      ]
    },
    "problem_statement": {
      "description": "Find the Greatest Common Divisor (GCD) of two numbers.",
      "constraints": [
        "1 <= A, B <= 10^9"
      ],
      "input_format": "Two integers A and B.",
      "output_format": "Their GCD.",
      "example": {
        "input": "12 18",
        "output": "6",
        "explanation": "Divisors of 12: 1,2,3,4,6,12. 18: 1,2,3,6,9,18. Max common is 6."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "10 5",
        "expected_output": "5",
        "explanation": "5 divides 10",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "13 7",
        "expected_output": "1",
        "explanation": "Co-prime",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "100 100",
        "expected_output": "100",
        "explanation": "Same numbers",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use loops to find common factors (Naive).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Euclidean algorithm is better: gcd(a, b) = gcd(b, a % b).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Repeat until b becomes 0, then a is GCD.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Recursive or Iterative implementation both work.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log(min(A,B)))",
      "space_complexity": "O(1)",
      "optimal_approach": "Euclidean Algorithm."
    }
  },
  {
    "problem_id": "Q027",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Math",
      "title": "LCM of Two Numbers",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "GCD Relation"
      ]
    },
    "problem_statement": {
      "description": "Find the Least Common Multiple (LCM) of two numbers.",
      "constraints": [
        "1 <= A, B <= 10000"
      ],
      "input_format": "Two integers A and B.",
      "output_format": "Their LCM.",
      "example": {
        "input": "4 6",
        "output": "12",
        "explanation": "Multiples of 4: 4,8,12... 6: 6,12... Match at 12."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 7",
        "expected_output": "35",
        "explanation": "Product of primes",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 4",
        "expected_output": "4",
        "explanation": "One is multiple of other",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1 5",
        "expected_output": "5",
        "explanation": "LCM with 1",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Relationship: LCM(a, b) = (a * b) / GCD(a, b).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 2,
        "hint_text": "Find GCD first.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Be careful of overflow when calculating a*b.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Use long long for product.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log(min(A,B))) due to GCD",
      "space_complexity": "O(1)",
      "optimal_approach": "Formula using GCD."
    }
  },
  {
    "problem_id": "Q028",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Math",
      "title": "Prime Check",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Loop Optimization",
        "Sqrt"
      ]
    },
    "problem_statement": {
      "description": "Check if a number is Prime.",
      "constraints": [
        "1 <= N <= 10^9"
      ],
      "input_format": "Integer N.",
      "output_format": "Print 'Yes' or 'No'.",
      "example": {
        "input": "7",
        "output": "Yes",
        "explanation": "Only divisible by 1 and 7."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4",
        "expected_output": "No",
        "explanation": "Divisible by 2",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "No",
        "explanation": "1 is not prime",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2",
        "expected_output": "Yes",
        "explanation": "2 is prime",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Loop from 2 to N-1 check divisibility.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Optimization: Loop only up to sqrt(N).",
        "hint_type": "optimization"
      },
      {
        "hint_level": 3,
        "hint_text": "If factors found, return No immediately.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Handle N=1 separately.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(sqrt(N))",
      "space_complexity": "O(1)",
      "optimal_approach": "Sqrt optimization."
    }
  },
  {
    "problem_id": "Q029",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Math",
      "title": "Armstrong Number",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "TCS"
      ],
      "learning_outcomes": [
        "Digit Logic"
      ]
    },
    "problem_statement": {
      "description": "Check if a number is an Armstrong number (sum of cubes of digits equals the number itself, for 3 digit numbers. Generally sum of digits raised to power of count of digits). Assume 3 digits for basic version or general.",
      "constraints": [
        "1 <= N <= 10000"
      ],
      "input_format": "Integer N.",
      "output_format": "Print 'Yes' or 'No'.",
      "example": {
        "input": "153",
        "output": "Yes",
        "explanation": "1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "370",
        "expected_output": "Yes",
        "explanation": "3^3 + 7^3 + 0^3 = 27 + 343 + 0 = 370",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "123",
        "expected_output": "No",
        "explanation": "Not armstrong",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1634",
        "expected_output": "Yes",
        "explanation": "1^4 + 6^4 + 3^4 + 4^4 = 1634",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Count digits first (D).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Extract each digit, raise to power D, sum it.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Compare sum with original number.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Be careful with updating the number variable, keep a copy.",
        "hint_type": "common_mistake"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Digit extraction."
    }
  },
  {
    "problem_id": "Q030",
    "metadata": {
      "week": 1,
      "day": 6,
      "topic": "Math",
      "title": "Count Digits",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 5,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Digit Extraction"
      ]
    },
    "problem_statement": {
      "description": "Count the number of digits in an integer.",
      "constraints": [
        "0 <= N <= 10^15"
      ],
      "input_format": "Integer N.",
      "output_format": "Count of digits.",
      "example": {
        "input": "12345",
        "output": "5",
        "explanation": "5 digits."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0",
        "expected_output": "1",
        "explanation": "0 has 1 digit",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "999",
        "expected_output": "3",
        "explanation": "3 digits",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "100000",
        "expected_output": "6",
        "explanation": "6 digits",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Repeatedly divide by 10 until 0.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Increment counter in each step.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Handle 0 explicitly (loop condition N > 0 might miss it).",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 4,
        "hint_text": "Alternatively convert to string and take length.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Logarithm or Loop."
    }
  },
  {
    "problem_id": "Q031",
    "metadata": {
      "week": 2,
      "day": 1,
      "topic": "Arrays",
      "title": "Second Largest Element",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "GeeksforGeeks",
        "Samsung"
      ],
      "learning_outcomes": [
        "Traversal",
        "Conditional Logic"
      ]
    },
    "problem_statement": {
      "description": "Find the second largest distinct element in an array.",
      "constraints": [
        "2 <= N <= 1000",
        "0 <= Elements <= 10^4"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Second largest element, or -1 if not exists.",
      "example": {
        "input": "5\n10 5 10 2 9",
        "output": "9",
        "explanation": "Largest 10, Second Largest 9."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n10 20 5",
        "expected_output": "10",
        "explanation": "20 is largest, 10 is second",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2\n10 10",
        "expected_output": "-1",
        "explanation": "No distinct second element",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5\n1 2 3 4 5",
        "expected_output": "4",
        "explanation": "Sorted",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Sort and pick second last? O(N log N). Can we do O(N)?",
        "hint_type": "optimization"
      },
      {
        "hint_level": 2,
        "hint_text": "Maintain two variables: largest AND second_largest.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Update largest if curr > largest. Then old largest becomes second largest.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Also check if curr > second_largest but < largest.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "One pass traversal."
    }
  },
  {
    "problem_id": "Q032",
    "metadata": {
      "week": 2,
      "day": 1,
      "topic": "Arrays",
      "title": "Left Rotate Array by One",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Array Manipulation"
      ]
    },
    "problem_statement": {
      "description": "Left rotate an array by one position. First element moves to last.",
      "constraints": [
        "1 <= N <= 1000"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Modified array.",
      "example": {
        "input": "5\n1 2 3 4 5",
        "output": "2 3 4 5 1",
        "explanation": "1 moved to end."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n10 20 30",
        "expected_output": "20 30 10",
        "explanation": "Standard rotation",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n5",
        "expected_output": "5",
        "explanation": "Single element stays",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2\n1 2",
        "expected_output": "2 1",
        "explanation": "Swap",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Store first element in temp.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Shift all other elements one step left (arr[i] = arr[i+1]).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Place temp at last index.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Loop from 0 to N-2.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "One pass."
    }
  },
  {
    "problem_id": "Q033",
    "metadata": {
      "week": 2,
      "day": 1,
      "topic": "Arrays",
      "title": "Rotate Array by K",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Microsoft",
        "Amazon"
      ],
      "learning_outcomes": [
        "Array Reversal",
        "Modulo Arithmetic"
      ]
    },
    "problem_statement": {
      "description": "Rotate an array to the left by K positions.",
      "constraints": [
        "1 <= N <= 1000",
        "0 <= K <= 1000"
      ],
      "input_format": "N, K, then N integers.",
      "output_format": "Rotated array.",
      "example": {
        "input": "5 2\n1 2 3 4 5",
        "output": "3 4 5 1 2",
        "explanation": "Rotated twice."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 1\n1 2 3",
        "expected_output": "2 3 1",
        "explanation": "Rotate 1",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "3 4\n1 2 3",
        "expected_output": "2 3 1",
        "explanation": "K > N, effective 1",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3 3\n1 2 3",
        "expected_output": "1 2 3",
        "explanation": "Rotate N times same array",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "K could be > N. Use K = K % N.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 2,
        "hint_text": "Naive: Rotate by 1, K times. O(N*K). Too slow.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 3,
        "hint_text": "Better: Use temp array for first K elements.",
        "hint_type": "approach"
      },
      {
        "hint_level": 4,
        "hint_text": "Optimal: Reversal Algorithm. Reverse(0, K-1), Reverse(K, N-1), Reverse(0, N-1).",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1) with reversal algorithm",
      "optimal_approach": "Reversal Algorithm."
    }
  },
  {
    "problem_id": "Q034",
    "metadata": {
      "week": 2,
      "day": 1,
      "topic": "Arrays",
      "title": "Move Zeros to End",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Paytm"
      ],
      "learning_outcomes": [
        "Two Pointer",
        "Partition"
      ]
    },
    "problem_statement": {
      "description": "Move all zeros to the end of the array while maintaining the relative order of non-zero elements.",
      "constraints": [
        "1 <= N <= 1000",
        "Elements can be 0"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Modified array.",
      "example": {
        "input": "5\n0 1 0 3 12",
        "output": "1 3 12 0 0",
        "explanation": "Zeros moved to back."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n0 0 1",
        "expected_output": "1 0 0",
        "explanation": "Shift front",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "4\n1 2 3 4",
        "expected_output": "1 2 3 4",
        "explanation": "No zeros",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "3\n0 0 0",
        "expected_output": "0 0 0",
        "explanation": "All zeros",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Create a new array? Requires O(N) space. Try in-place.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Keep a pointer 'count' for non-zero position.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Iterate, if non-zero found, place at 'count' and increment count.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "After loop, fill remaining from 'count' to end with zeros.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Two pointer traversal."
    }
  },
  {
    "problem_id": "Q035",
    "metadata": {
      "week": 2,
      "day": 2,
      "topic": "Arrays",
      "title": "Remove Duplicates from Sorted Array",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Two Pointer",
        "Sorted Array Property"
      ]
    },
    "problem_statement": {
      "description": "Remove duplicates from a sorted array in-place. Return the new length and print the unique elements.",
      "constraints": [
        "1 <= N <= 1000",
        "Sorted Non-Decreasing"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Length, then space separated unique elements.",
      "example": {
        "input": "5\n1 1 2 2 3",
        "output": "3\n1 2 3",
        "explanation": "Unique elements 1, 2, 3. Length 3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n1 1 1",
        "expected_output": "1\n1",
        "explanation": "All duplicate",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "3\n1 2 3",
        "expected_output": "3\n1 2 3",
        "explanation": "No duplicates",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "6\n1 1 2 3 3 4",
        "expected_output": "4\n1 2 3 4",
        "explanation": "Mixed",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Since sorted, duplicates are adjacent.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use a pointer 'j' to track unique position.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If arr[i] != arr[i-1], add to arr[j].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Return j.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Two pointer pass."
    }
  },
  {
    "problem_id": "Q036",
    "metadata": {
      "week": 2,
      "day": 2,
      "topic": "Arrays",
      "title": "Linear Search - All Occurrences",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Traversal",
        "Index Tracking"
      ]
    },
    "problem_statement": {
      "description": "Find indices of all occurrences of element K in the array.",
      "constraints": [
        "1 <= N <= 1000",
        "0-based indexing"
      ],
      "input_format": "N, K, then N integers.",
      "output_format": "Space separated indices, or -1 if none.",
      "example": {
        "input": "5 2\n1 2 3 2 4",
        "output": "1 3",
        "explanation": "2 found at index 1 and 3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 5\n1 2 3",
        "expected_output": "-1",
        "explanation": "Not found",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "4 1\n1 1 1 1",
        "expected_output": "0 1 2 3",
        "explanation": "All indices",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1 10\n10",
        "expected_output": "0",
        "explanation": "Single index",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Iterate and check each element.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Store or print indices immediately.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Use a flag to check if found at least once.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "If flag is false after loop, print -1.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Linear scan."
    }
  },
  {
    "problem_id": "Q037",
    "metadata": {
      "week": 2,
      "day": 3,
      "topic": "Searching",
      "title": "Binary Search (Iterative)",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Most Companies"
      ],
      "learning_outcomes": [
        "Binary Search",
        "Divide & Conquer"
      ]
    },
    "problem_statement": {
      "description": "Implement Binary Search to find K in a sorted array. Return index or -1.",
      "constraints": [
        "1 <= N <= 10^4",
        "Sorted Array"
      ],
      "input_format": "N, K, then N integers.",
      "output_format": "Index of K.",
      "example": {
        "input": "5 4\n1 2 4 5 6",
        "output": "2",
        "explanation": "4 is at index 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 1\n2 3 4",
        "expected_output": "-1",
        "explanation": "Not found",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "5 6\n1 2 4 5 6",
        "expected_output": "4",
        "explanation": "Last element",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5 1\n1 2 4 5 6",
        "expected_output": "0",
        "explanation": "First element",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Array is sorted. Don't use linear search.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Start low=0, high=N-1.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "mid = low + (high - low) / 2.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If arr[mid] < K, ignore left half (low = mid + 1).",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Binary Search."
    }
  },
  {
    "problem_id": "Q038",
    "metadata": {
      "week": 2,
      "day": 3,
      "topic": "Searching",
      "title": "Binary Search (Recursive)",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Recursion",
        "Binary Search"
      ]
    },
    "problem_statement": {
      "description": "Implement Recursive Binary Search.",
      "constraints": [
        "1 <= N <= 10^4"
      ],
      "input_format": "N, K, then N integers.",
      "output_format": "Index of K.",
      "example": {
        "input": "3 2\n1 2 3",
        "output": "1",
        "explanation": "At index 1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 10\n1 3 5 7 9",
        "expected_output": "-1",
        "explanation": "Not found",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 5\n5",
        "expected_output": "0",
        "explanation": "Single match",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4 4\n1 2 3 4",
        "expected_output": "3",
        "explanation": "Found",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Function signature: search(arr, low, high, key).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Base case: low > high return -1.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Compute mid.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Call recursively based on comparison.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log N)",
      "space_complexity": "O(log N) stack",
      "optimal_approach": "Recursive Binary Search."
    }
  },
  {
    "problem_id": "Q039",
    "metadata": {
      "week": 2,
      "day": 3,
      "topic": "Sorting",
      "title": "Bubble Sort",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Sorting Algorithms",
        "Swapping"
      ]
    },
    "problem_statement": {
      "description": "Sort an array using Bubble Sort algorithm.",
      "constraints": [
        "1 <= N <= 1000"
      ],
      "input_format": "N followed by N integers.",
      "output_format": "Sorted array.",
      "example": {
        "input": "4\n4 1 3 2",
        "output": "1 2 3 4",
        "explanation": "Sorted."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n3 2 1",
        "expected_output": "1 2 3",
        "explanation": "Reverse sorted",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "3\n1 2 3",
        "expected_output": "1 2 3",
        "explanation": "Already sorted",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5\n5 1 4 2 8",
        "expected_output": "1 2 4 5 8",
        "explanation": "Unsorted",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Repeatedly swap adjacent elements if they are in wrong order.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Largest element 'bubbles' to the end in first pass.",
        "hint_type": "visual"
      },
      {
        "hint_level": 3,
        "hint_text": "Inner loop range decreases by 1 each time.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Optimization: Check if any swap happened in a pass.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(1)",
      "optimal_approach": "Bubble Sort (for learning)."
    }
  },
  {
    "problem_id": "Q040",
    "metadata": {
      "week": 2,
      "day": 3,
      "topic": "Arrays",
      "title": "Insert Element at Index",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Array Shifting"
      ]
    },
    "problem_statement": {
      "description": "Insert an element X at a specific index I in an array, shifting other elements.",
      "constraints": [
        "1 <= N <= 1000",
        "0 <= I <= N"
      ],
      "input_format": "N, Array, then X and I.",
      "output_format": "Modified array.",
      "example": {
        "input": "5\n1 2 3 4 5\n10 2",
        "output": "1 2 10 3 4 5",
        "explanation": "10 inserted at index 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n1 2 3\n5 0",
        "expected_output": "5 1 2 3",
        "explanation": "Insert at beginning",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "3\n1 2 3\n5 3",
        "expected_output": "1 2 3 5",
        "explanation": "Insert at end",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0\n\n5 0",
        "expected_output": "5",
        "explanation": "Empty array",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Array size increases by 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Shift elements from index I to end one step right.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Start shifting from the back to avoid overwriting.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Place X at index I.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1) (assuming capacity)",
      "optimal_approach": "Shifting."
    }
  },
  {
    "problem_id": "Q041",
    "metadata": {
      "week": 2,
      "day": 4,
      "topic": "Strings",
      "title": "Reverse a String",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "String Traversal",
        "In-place"
      ]
    },
    "problem_statement": {
      "description": "Reverse a given string.",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "A string S.",
      "output_format": "Reversed string.",
      "example": {
        "input": "hello",
        "output": "olleh",
        "explanation": "Reversed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "abcd",
        "expected_output": "dcba",
        "explanation": "Standard",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "a",
        "expected_output": "a",
        "explanation": "Single char",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "madam",
        "expected_output": "madam",
        "explanation": "Palindrome",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Strings can be treated as array of characters.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use two pointers: start=0, end=len-1.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Swap chars at start and end.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Strings might be immutable in Java/Python, convert to char array first.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N) if immutable, else O(1)",
      "optimal_approach": "Two pointer swap."
    }
  },
  {
    "problem_id": "Q042",
    "metadata": {
      "week": 2,
      "day": 4,
      "topic": "Strings",
      "title": "Palindrome String",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "TCS"
      ],
      "learning_outcomes": [
        "Two Pointer"
      ]
    },
    "problem_statement": {
      "description": "Check if a string is a palindrome.",
      "constraints": [
        "1 <= Length <= 1000",
        "English letters"
      ],
      "input_format": "String S.",
      "output_format": "Print 'Yes' or 'No'.",
      "example": {
        "input": "level",
        "output": "Yes",
        "explanation": "Reads same forward and backward."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "hello",
        "expected_output": "No",
        "explanation": "olleh != hello",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "racecar",
        "expected_output": "Yes",
        "explanation": "Palindrome",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "a",
        "expected_output": "Yes",
        "explanation": "Single char",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Compare first and last characters.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Move inwards as long as characters match.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If mismatch found, return No.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Handle case sensitivity if needed (problem implies lowercase).",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Two pointer comparison."
    }
  },
  {
    "problem_id": "Q043",
    "metadata": {
      "week": 2,
      "day": 4,
      "topic": "Strings",
      "title": "Count Vowels and Consonants",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Character Checks"
      ]
    },
    "problem_statement": {
      "description": "Count the number of vowels and consonants in a string.",
      "constraints": [
        "1 <= Length <= 1000",
        "Alphabets only"
      ],
      "input_format": "String S.",
      "output_format": "Vowels Consonants",
      "example": {
        "input": "hello",
        "output": "2 3",
        "explanation": "e, o are vowels. h, l, l are consonants."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "aeiou",
        "expected_output": "5 0",
        "explanation": "All vowels",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "bcd",
        "expected_output": "0 3",
        "explanation": "All consonants",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "Apple",
        "expected_output": "2 3",
        "explanation": "Mixed case, check both",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Vowels are a, e, i, o, u (both cases).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterate through string.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If char is vowel, v_count++, else if letter, c_count++.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Ignore spaces/digits if present (constraints say alphabets only).",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Linear scan."
    }
  },
  {
    "problem_id": "Q044",
    "metadata": {
      "week": 2,
      "day": 4,
      "topic": "Strings",
      "title": "Anagram Check",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Amazon"
      ],
      "learning_outcomes": [
        "Hashing",
        "Sorting"
      ]
    },
    "problem_statement": {
      "description": "Check if two strings are anagrams (contain same characters with same frequency).",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "Two strings S1 and S2.",
      "output_format": "Yes or No.",
      "example": {
        "input": "listen silent",
        "output": "Yes",
        "explanation": "Same letters."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "cat rat",
        "expected_output": "No",
        "explanation": "Different chars",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "abc cab",
        "expected_output": "Yes",
        "explanation": "Anagram",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "a aa",
        "expected_output": "No",
        "explanation": "Different frequencies",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Method 1: Sort both strings and compare. O(N log N).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Method 2: Use frequency array (size 26) or hash map. O(N).",
        "hint_type": "optimization"
      },
      {
        "hint_level": 3,
        "hint_text": "Increment count for S1, decrement for S2.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Check if all counts are zero at end.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1) (fixed size 26)",
      "optimal_approach": "Frequency Counter."
    }
  },
  {
    "problem_id": "Q045",
    "metadata": {
      "week": 2,
      "day": 4,
      "topic": "Strings",
      "title": "Remove Spaces",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "String Modification"
      ]
    },
    "problem_statement": {
      "description": "Remove all spaces from a given string.",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "String S (may contain spaces).",
      "output_format": "String without spaces.",
      "example": {
        "input": "hello world",
        "output": "helloworld",
        "explanation": "Space removed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "a b c",
        "expected_output": "abc",
        "explanation": "Multiple spaces",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "  a  ",
        "expected_output": "a",
        "explanation": "Leading/Trailing",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "nospace",
        "expected_output": "nospace",
        "explanation": "No change",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Iterate through string.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Append non-space characters to new buffer/string.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If char != ' ', add it.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Print the result.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N) for result",
      "optimal_approach": "Builder pattern."
    }
  },
  {
    "problem_id": "Q046",
    "metadata": {
      "week": 2,
      "day": 5,
      "topic": "Strings",
      "title": "First Non-Repeating Character",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google"
      ],
      "learning_outcomes": [
        "Hashing",
        "Frequency Map"
      ]
    },
    "problem_statement": {
      "description": "Find the first non-repeating character in a string and return its character.",
      "constraints": [
        "1 <= Length <= 1000",
        "Lowercase English"
      ],
      "input_format": "String S.",
      "output_format": "Char (or specific message if none, say -1 or None). Let's print the Char.",
      "example": {
        "input": "leetcode",
        "output": "l",
        "explanation": "l appears once."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "loveleetcode",
        "expected_output": "v",
        "explanation": "l, o, e repeated. v is first unique.",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "aabb",
        "expected_output": "-1",
        "explanation": "All repeat",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "z",
        "expected_output": "z",
        "explanation": "Single char",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Need to know counts of all chars completely first?",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Step 1: Count frequency of each char (Hash Map or Array).",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Step 2: Iterate string again.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Return the first char with count == 1.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1) (26 chars)",
      "optimal_approach": "Two pass with frequency array."
    }
  },
  {
    "problem_id": "Q047",
    "metadata": {
      "week": 2,
      "day": 5,
      "topic": "Strings",
      "title": "String Compression",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Microsoft"
      ],
      "learning_outcomes": [
        "Run Length Encoding"
      ]
    },
    "problem_statement": {
      "description": "Compress a string by replacing consecutive repeating characters with count (e.g., aabcccccaaa -> a2b1c5a3).",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "String S.",
      "output_format": "Compressed String.",
      "example": {
        "input": "aabcccccaaa",
        "output": "a2b1c5a3",
        "explanation": "Compressed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "abc",
        "expected_output": "a1b1c1",
        "explanation": "No repeats",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "aaaaa",
        "expected_output": "a5",
        "explanation": "Single run",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "a",
        "expected_output": "a1",
        "explanation": "Single char",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Traverse the string.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Keep count of consecutive characters.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "When char changes, append prev char + count to result.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Don't forget the last group after loop ends.",
        "hint_type": "common_mistake"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Linear scan."
    }
  },
  {
    "problem_id": "Q048",
    "metadata": {
      "week": 2,
      "day": 5,
      "topic": "Strings",
      "title": "Longest Common Prefix",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Google"
      ],
      "learning_outcomes": [
        "String Algorithms"
      ]
    },
    "problem_statement": {
      "description": "Find the longest common prefix string amongst an array of strings.",
      "constraints": [
        "1 <= N strings <= 200",
        "0 <= String Length <= 200"
      ],
      "input_format": "N followed by N strings.",
      "output_format": "LCP String or empty.",
      "example": {
        "input": "3\nflower flow flight",
        "output": "fl",
        "explanation": "fl is common."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\ndog racecar car",
        "expected_output": "",
        "explanation": "No common prefix",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2\nab a",
        "expected_output": "a",
        "explanation": "Shortest string limit",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1\nalone",
        "expected_output": "alone",
        "explanation": "Single string LCP is itself",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "LCP is at most the length of shortest string.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Take first string as initial prefix.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Compare with next string, shorten prefix until it matches.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Repeat for all strings.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(S) where S is sum of all chars",
      "space_complexity": "O(1)",
      "optimal_approach": "Horizontal scanning."
    }
  },
  {
    "problem_id": "Q049",
    "metadata": {
      "week": 2,
      "day": 5,
      "topic": "Strings",
      "title": "Reverse Words in a String",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "String Parsing"
      ]
    },
    "problem_statement": {
      "description": "Reverse the order of words in a given string. Words are separated by space.",
      "constraints": [
        "1 <= Length <= 1000",
        "Single spaces between words"
      ],
      "input_format": "String S.",
      "output_format": "Reversed words string.",
      "example": {
        "input": "the sky is blue",
        "output": "blue is sky the",
        "explanation": "Words reversed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "hello world",
        "expected_output": "world hello",
        "explanation": "Swapped",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "a",
        "expected_output": "a",
        "explanation": "Single word",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "a b c",
        "expected_output": "c b a",
        "explanation": "Three words",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Split string by space.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "You get a list of words. Reverse the list.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Join them back with spaces.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Without split (in-place): Reverse whole string, then reverse individual words.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Split and Reverse."
    }
  },
  {
    "problem_id": "Q050",
    "metadata": {
      "week": 2,
      "day": 5,
      "topic": "Strings",
      "title": "String Rotation Check",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "TCS"
      ],
      "learning_outcomes": [
        "Rotation Logic"
      ]
    },
    "problem_statement": {
      "description": "Check if one string is a rotation of another.",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "Two strings S1 and S2.",
      "output_format": "Yes or No.",
      "example": {
        "input": "waterbottle erbottlewat",
        "output": "Yes",
        "explanation": "Rotation."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "abc bca",
        "expected_output": "Yes",
        "explanation": "abc -> bca",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "abc acb",
        "expected_output": "No",
        "explanation": "Not rotation",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "aa aa",
        "expected_output": "Yes",
        "explanation": "Identical",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Length must be equal.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Concatenate S1 with itself: S1 + S1.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Check if S2 is a substring of (S1 + S1).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "waterbottlewaterbottle contains erbottlewat.",
        "hint_type": "visual"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Concatenation trick."
    }
  },
  {
    "problem_id": "Q051",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Matrix",
      "title": "Spiral Matrix Transversal",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Microsoft",
        "Apple"
      ],
      "learning_outcomes": [
        "Matrix Traversal"
      ]
    },
    "problem_statement": {
      "description": "Given an m x n matrix, return all elements of the matrix in spiral order.",
      "constraints": [
        "1 <= m, n <= 10"
      ],
      "input_format": "m, n, then matrix rows.",
      "output_format": "Space separated elements.",
      "example": {
        "input": "3 3\n1 2 3\n4 5 6\n7 8 9",
        "output": "1 2 3 6 9 8 7 4 5",
        "explanation": "Spiral order."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 3\n1 2 3\n4 5 6\n7 8 9",
        "expected_output": "1 2 3 6 9 8 7 4 5",
        "explanation": "Square matrix",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 3\n1 2 3",
        "expected_output": "1 2 3",
        "explanation": "Single row",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3 1\n1\n2\n3",
        "expected_output": "1 2 3",
        "explanation": "Single col",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use 4 boundaries: top, bottom, left, right.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Loop while top <= bottom and left <= right.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Move Right, Down, Left, Up, updating boundaries.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Be careful with corner cases inside loop to avoid double printing.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(m*n)",
      "space_complexity": "O(1)",
      "optimal_approach": "Boundary Simulation."
    }
  },
  {
    "problem_id": "Q052",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Matrix",
      "title": "Transpose Matrix",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Matrix Operations"
      ]
    },
    "problem_statement": {
      "description": "Transpose a matrix (flip over its main diagonal).",
      "constraints": [
        "1 <= N <= 100"
      ],
      "input_format": "N (Rows), M (Cols), Matrix.",
      "output_format": "Transposed Matrix.",
      "example": {
        "input": "2 3\n1 2 3\n4 5 6",
        "output": "1 4\n2 5\n3 6",
        "explanation": "Rows become cols."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 2\n1 2\n3 4",
        "expected_output": "1 3\n2 4",
        "explanation": "Square",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 3\n1 2 3\n4 5 6",
        "expected_output": "1 4\n2 5\n3 6",
        "explanation": "Rectangular",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1 1\n5",
        "expected_output": "5",
        "explanation": "Single element",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "New matrix dimensions will be M x N.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "new_mat[j][i] = old_mat[i][j].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Double loop structures.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Print row by row.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N*M)",
      "space_complexity": "O(N*M)",
      "optimal_approach": "Direct mapping."
    }
  },
  {
    "problem_id": "Q053",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Matrix",
      "title": "Search a 2D Matrix",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Binary Search in 2D"
      ]
    },
    "problem_statement": {
      "description": "Search for a value in an m x n matrix where each row is sorted and the first integer of each row is greater than the last integer of the previous row.",
      "constraints": [
        "1 <= m, n <= 100",
        "Target in range"
      ],
      "input_format": "m, n, Target, Matrix.",
      "output_format": "Yes or No.",
      "example": {
        "input": "3 4 3\n1 3 5 7\n10 11 16 20\n23 30 34 60",
        "output": "Yes",
        "explanation": "3 is present."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 3 5\n1 2 3\n4 5 6\n7 8 9",
        "expected_output": "Yes",
        "explanation": "Found",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 2 10\n1 2\n3 4",
        "expected_output": "No",
        "explanation": "Not found",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1 1 1\n1",
        "expected_output": "Yes",
        "explanation": "Single",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Treat the matrix as a flattened sorted array.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Total elements = m*n. Range 0 to m*n-1.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Binary search on index mid: row = mid/n, col = mid%n.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Compare matrix[row][col] with target.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log(m*n))",
      "space_complexity": "O(1)",
      "optimal_approach": "Binary Search."
    }
  },
  {
    "problem_id": "Q054",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Strings",
      "title": "Longest Palindromic Substring",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 30,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Dynamic Programming",
        "Center Expansion"
      ]
    },
    "problem_statement": {
      "description": "Given a string S, return the longest palindromic substring in S.",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "String S.",
      "output_format": "The substring.",
      "example": {
        "input": "babad",
        "output": "bab",
        "explanation": "aba is also valid."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "cbbd",
        "expected_output": "bb",
        "explanation": "bb is longest",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "a",
        "expected_output": "a",
        "explanation": "Single char",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "ac",
        "expected_output": "a",
        "explanation": "First char",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Brute force checks all substrings O(N^3). Too slow.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Expand Around Center approach.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "For each character, consider it as center (odd length) and pair (even length).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Expand left and right while match.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(1)",
      "optimal_approach": "Expand Around Center."
    }
  },
  {
    "problem_id": "Q055",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Stack",
      "title": "Valid Parentheses",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Amazon"
      ],
      "learning_outcomes": [
        "Stack",
        "Matching"
      ]
    },
    "problem_statement": {
      "description": "Given a string containing '(', ')', '{', '}', '[' and ']', determine if the input string is valid (closed in correct order).",
      "constraints": [
        "1 <= Length <= 1000"
      ],
      "input_format": "String S.",
      "output_format": "Yes or No.",
      "example": {
        "input": "()[]{}",
        "output": "Yes",
        "explanation": "Valid."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "(]",
        "expected_output": "No",
        "explanation": "Mismatch",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "([)]",
        "expected_output": "No",
        "explanation": "Wrong order",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "{[]}",
        "expected_output": "Yes",
        "explanation": "Nested",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use a Stack data structure.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Push opening brackets.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "On closing bracket, check top of stack.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Stack must be empty at end.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Stack."
    }
  },
  {
    "problem_id": "Q056",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Strings",
      "title": "Group Anagrams",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon"
      ],
      "learning_outcomes": [
        "Hashing",
        "Sorting"
      ]
    },
    "problem_statement": {
      "description": "Group an array of strings into anagrams.",
      "constraints": [
        "1 <= N <= 100"
      ],
      "input_format": "N followed by N strings.",
      "output_format": "Print groups on separate lines.",
      "example": {
        "input": "3\neat tea tan",
        "output": "eat tea\ntan",
        "explanation": "eat and tea are anagrams."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\na b a",
        "expected_output": "a a\nb",
        "explanation": "Grouped",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2\nabc def",
        "expected_output": "abc\ndef",
        "explanation": "No anagrams",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "4\ncat dog tac god",
        "expected_output": "cat tac\ndog god",
        "explanation": "Multiple groups",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Two strings are anagrams if sorted versions are same.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use a Map where key is sorted string.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Value is list of original strings.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Iterate Map to print groups.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N * K log K)",
      "space_complexity": "O(N*K)",
      "optimal_approach": "HashMap with Sorted Key."
    }
  },
  {
    "problem_id": "Q057",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Matrix",
      "title": "Rotate Image",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Matrix In-place"
      ]
    },
    "problem_statement": {
      "description": "Rotate an N x N matrix by 90 degrees clockwise in-place.",
      "constraints": [
        "1 <= N <= 10"
      ],
      "input_format": "N, Matrix.",
      "output_format": "Rotated Matrix.",
      "example": {
        "input": "2\n1 2\n3 4",
        "output": "3 1\n4 2",
        "explanation": "Rotated."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n1 2 3\n4 5 6\n7 8 9",
        "expected_output": "7 4 1\n8 5 2\n9 6 3",
        "explanation": "Standard",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n5",
        "expected_output": "5",
        "explanation": "Identity",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2\n5 1\n2 4",
        "expected_output": "2 5\n4 1",
        "explanation": "2x2",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Transpose the matrix first.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Then reverse each row.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Transpose: swap(mat[i][j], mat[j][i]).",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Reverse Row: swap start and end elements.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(1)",
      "optimal_approach": "Transpose + Reverse."
    }
  },
  {
    "problem_id": "Q058",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Arrays",
      "title": "Pascal's Triangle",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Apple"
      ],
      "learning_outcomes": [
        "Dynamic Programming Basics"
      ]
    },
    "problem_statement": {
      "description": "Generate first N rows of Pascal's Triangle.",
      "constraints": [
        "1 <= N <= 20"
      ],
      "input_format": "Integer N.",
      "output_format": "Rows of triangle.",
      "example": {
        "input": "3",
        "output": "1\n1 1\n1 2 1",
        "explanation": "Row 3 is sum of elements above."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2",
        "expected_output": "1\n1 1",
        "explanation": "2 rows",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "1 row",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4",
        "expected_output": "1\n1 1\n1 2 1\n1 3 3 1",
        "explanation": "4 rows",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "First and last element of each row is 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Inner elements: arr[i][j] = arr[i-1][j-1] + arr[i-1][j].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Use a 2D array or list of lists.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Be careful with indexing bounds.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(N^2)",
      "optimal_approach": "Iterative generation."
    }
  },
  {
    "problem_id": "Q059",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Matrix",
      "title": "Set Matrix Zeroes",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Facebook"
      ],
      "learning_outcomes": [
        "Space Optimization"
      ]
    },
    "problem_statement": {
      "description": "Given an m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.",
      "constraints": [
        "1 <= m, n <= 20"
      ],
      "input_format": "m, n, Matrix.",
      "output_format": "Modified Matrix.",
      "example": {
        "input": "3 3\n1 1 1\n1 0 1\n1 1 1",
        "output": "1 0 1\n0 0 0\n1 0 1",
        "explanation": "Center was 0."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 2\n0 1\n1 1",
        "expected_output": "0 0\n0 1",
        "explanation": "Corner 0",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 2\n1 1\n1 1",
        "expected_output": "1 1\n1 1",
        "explanation": "No zeroes",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "3 3\n0 1 1\n1 1 1\n1 1 1",
        "expected_output": "0 0 0\n0 1 1\n0 1 1",
        "explanation": "Corner propagation",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "If you just modify while traversing, you will mess up future checks.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use two arrays row[] and col[] to store which rows/cols need to be 0.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Space O(m+n). Can you do O(1)?",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Use first row and first column as the dummy arrays.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(m*n)",
      "space_complexity": "O(1) optimal",
      "optimal_approach": "First row/col markers."
    }
  },
  {
    "problem_id": "Q060",
    "metadata": {
      "week": 2,
      "day": 6,
      "topic": "Math",
      "title": "Roman to Integer",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "Facebook"
      ],
      "learning_outcomes": [
        "Hash Map",
        "Logic"
      ]
    },
    "problem_statement": {
      "description": "Convert a Roman numeral to an integer.",
      "constraints": [
        "1 <= Length <= 15",
        "Valid Roman"
      ],
      "input_format": "String S.",
      "output_format": "Integer Value.",
      "example": {
        "input": "III",
        "output": "3",
        "explanation": "1+1+1"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "IV",
        "expected_output": "4",
        "explanation": "5-1",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "IX",
        "expected_output": "9",
        "explanation": "10-1",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "MCMXCIV",
        "expected_output": "1994",
        "explanation": "Complex",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Map symbols to values (I=1, V=5...).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterate from left to right.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If val[i] < val[i+1], subtract val[i].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Otherwise add val[i].",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Comparisons."
    }
  },
  {
    "problem_id": "Q061",
    "metadata": {
      "week": 3,
      "day": 1,
      "topic": "Linked List",
      "title": "Traverse a Linked List",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Linked List Basics"
      ]
    },
    "problem_statement": {
      "description": "Given a linked list, print all its elements.",
      "constraints": [
        "0 <= N <= 1000"
      ],
      "input_format": "N followed by N integers (representing LL nodes).",
      "output_format": "Space separated values.",
      "example": {
        "input": "3\n1 2 3",
        "output": "1 2 3",
        "explanation": "Traversal."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2\n10 20",
        "expected_output": "10 20",
        "explanation": "Two nodes",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "",
        "explanation": "Empty list",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1\n5",
        "expected_output": "5",
        "explanation": "Single node",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Start at head.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Loop while current node is not null.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Print current.data.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Move to current.next.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Traversal."
    }
  },
  {
    "problem_id": "Q062",
    "metadata": {
      "week": 3,
      "day": 1,
      "topic": "Linked List",
      "title": "Insert Node at Head",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Pointer Manipulation"
      ]
    },
    "problem_statement": {
      "description": "Insert a new node at the beginning of the Linked List.",
      "constraints": [
        "0 <= N <= 1000"
      ],
      "input_format": "N, elements, then New_Value.",
      "output_format": "Modified list.",
      "example": {
        "input": "3\n1 2 3\n0",
        "output": "0 1 2 3",
        "explanation": "0 inserted at front."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2\n2 3\n1",
        "expected_output": "1 2 3",
        "explanation": "Standard",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0\n\n5",
        "expected_output": "5",
        "explanation": "Into empty list",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1\n10\n20",
        "expected_output": "20 10",
        "explanation": "Front",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Create new node with New_Value.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Set new_node.next = head.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Update head to new_node.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Return new head.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Pointer update."
    }
  },
  {
    "problem_id": "Q063",
    "metadata": {
      "week": 3,
      "day": 1,
      "topic": "Linked List",
      "title": "Delete Node",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Deletion"
      ]
    },
    "problem_statement": {
      "description": "Delete a node with value K from the linked list (first occurrence).",
      "constraints": [
        "0 <= N <= 1000"
      ],
      "input_format": "N, elements, K.",
      "output_format": "Modified list.",
      "example": {
        "input": "3\n1 2 3\n2",
        "output": "1 3",
        "explanation": "2 removed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3\n1 2 3\n1",
        "expected_output": "2 3",
        "explanation": "Head deletion",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "3\n1 2 3\n3",
        "expected_output": "1 2",
        "explanation": "Tail deletion",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3\n1 2 3\n4",
        "expected_output": "1 2 3",
        "explanation": "Not found",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Handle head case separately (if head.val == K).",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 2,
        "hint_text": "Traverse with prev and curr pointers.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If curr.val == K, set prev.next = curr.next.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Stop after deletion.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Traversal."
    }
  },
  {
    "problem_id": "Q064",
    "metadata": {
      "week": 3,
      "day": 2,
      "topic": "Linked List",
      "title": "Middle of Linked List",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Flipkart"
      ],
      "learning_outcomes": [
        "Fast and Slow Pointers"
      ]
    },
    "problem_statement": {
      "description": "Find the middle node of the linked list. If even nodes, second middle.",
      "constraints": [
        "0 <= N <= 1000"
      ],
      "input_format": "N, elements.",
      "output_format": "Middle node value.",
      "example": {
        "input": "5\n1 2 3 4 5",
        "output": "3",
        "explanation": "Middle."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "6\n1 2 3 4 5 6",
        "expected_output": "4",
        "explanation": "Even, 4 is second middle",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n10",
        "expected_output": "10",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2\n1 2",
        "expected_output": "2",
        "explanation": "Two elements",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Count nodes method requires 2 passes.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Use Fast and Slow pointers (Tortoise and Hare).",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "Slow moves 1 step, Fast moves 2 steps.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "When Fast reaches end, Slow is at middle.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Fast-Slow Pointers."
    }
  },
  {
    "problem_id": "Q065",
    "metadata": {
      "week": 3,
      "day": 2,
      "topic": "Linked List",
      "title": "Reverse Linked List",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Most Companies"
      ],
      "learning_outcomes": [
        "In-place Reversal"
      ]
    },
    "problem_statement": {
      "description": "Reverse a singly linked list.",
      "constraints": [
        "0 <= N <= 1000"
      ],
      "input_format": "N, elements.",
      "output_format": "Reversed list.",
      "example": {
        "input": "3\n1 2 3",
        "output": "3 2 1",
        "explanation": "Reversed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1\n5",
        "expected_output": "5",
        "explanation": "No change",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "2\n1 2",
        "expected_output": "2 1",
        "explanation": "Swap",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "0",
        "expected_output": "",
        "explanation": "Empty",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Iterative approach uses 3 pointers: prev, curr, next.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Save curr.next.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Set curr.next = prev.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Move prev and curr one step forward.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Iterative."
    }
  },
  {
    "problem_id": "Q066",
    "metadata": {
      "week": 3,
      "day": 2,
      "topic": "Linked List",
      "title": "Detect Cycle using Floyd's Cycle Detection",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Cycle Detection"
      ]
    },
    "problem_statement": {
      "description": "Check if linked list has a cycle.",
      "constraints": [
        "0 <= N <= 1000, pos denotes index where tail connects"
      ],
      "input_format": "N, elements, pos (input handled such that cycle is created if pos >= 0).",
      "output_format": "True or False.",
      "example": {
        "input": "4\n3 2 0 -4\n1",
        "output": "True",
        "explanation": "-4 connects to 2 (index 1)."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2\n1 2\n-1",
        "expected_output": "False",
        "explanation": "No cycle",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2\n1 2\n0",
        "expected_output": "True",
        "explanation": "Cycle at 0",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1\n1\n-1",
        "expected_output": "False",
        "explanation": "Single node no cycle",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use Fast and Slow pointers.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "If Fast and Slow meet, there is a cycle.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If Fast reaches NULL, no cycle.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Ensure Fast moves 2 steps, Slow 1.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Floyd's Algorithm."
    }
  },
  {
    "problem_id": "Q067",
    "metadata": {
      "week": 3,
      "day": 3,
      "topic": "Linked List",
      "title": "Merge Two Sorted Lists",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Basic"
      ],
      "learning_outcomes": [
        "Merging"
      ]
    },
    "problem_statement": {
      "description": "Merge two sorted linked lists into one sorted list.",
      "constraints": [
        "0 <= N,M <= 50"
      ],
      "input_format": "N, List1, M, List2.",
      "output_format": "Merged List.",
      "example": {
        "input": "3\n1 2 4\n3\n1 3 4",
        "output": "1 1 2 3 4 4",
        "explanation": "Merged."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0\n\n0\n",
        "expected_output": "",
        "explanation": "Both empty",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "0\n\n1\n0",
        "expected_output": "0",
        "explanation": "One empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2\n5 10\n2\n1 15",
        "expected_output": "1 5 10 15",
        "explanation": "Interleaved",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Create a dummy head for new list.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Compare heads of L1 and L2.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Attach smaller node to current.next and move pointer.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Attach remaining non-null list at the end.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N+M)",
      "space_complexity": "O(1)",
      "optimal_approach": "Iterative Merge."
    }
  },
  {
    "problem_id": "Q068",
    "metadata": {
      "week": 3,
      "day": 3,
      "topic": "Linked List",
      "title": "Remove Nth Node From End",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Facebook"
      ],
      "learning_outcomes": [
        "Two Pointer Gap"
      ]
    },
    "problem_statement": {
      "description": "Remove the Nth node from the end of the list and return its head.",
      "constraints": [
        "1 <= N <= Size"
      ],
      "input_format": "Size, List, N.",
      "output_format": "Modified List.",
      "example": {
        "input": "5\n1 2 3 4 5\n2",
        "output": "1 2 3 5",
        "explanation": "4 is 2nd from end."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1\n1\n1",
        "expected_output": "",
        "explanation": "Remove only node",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "2\n1 2\n1",
        "expected_output": "1",
        "explanation": "Remove last",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "2\n1 2\n2",
        "expected_output": "2",
        "explanation": "Remove first",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Two passes: Count length L, then remove (L-N+1)th node.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "One pass: Use two pointers with gap N.",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "Move Fast N steps ahead.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Then move both Fast and Slow until Fast is at end.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "One Pass."
    }
  },
  {
    "problem_id": "Q069",
    "metadata": {
      "week": 3,
      "day": 3,
      "topic": "Linked List",
      "title": "Palindrome Linked List",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "List Manipulation"
      ]
    },
    "problem_statement": {
      "description": "Check if a linked list is a palindrome.",
      "constraints": [
        "1 <= N <= 10^5"
      ],
      "input_format": "N, List.",
      "output_format": "True or False.",
      "example": {
        "input": "4\n1 2 2 1",
        "output": "True",
        "explanation": "Palindrome."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2\n1 2",
        "expected_output": "False",
        "explanation": "Not palindrome",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1\n1",
        "expected_output": "True",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3\n1 0 1",
        "expected_output": "True",
        "explanation": "Palindrome",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Stack method: push all, then pop and compare. O(N) space.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "O(1) space: Find middle.",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "Reverse the second half.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Compare first half and reversed second half.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Reverse Half."
    }
  },
  {
    "problem_id": "Q070",
    "metadata": {
      "week": 3,
      "day": 3,
      "topic": "Linked List",
      "title": "Intersection of Two Linked Lists",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Length Difference"
      ]
    },
    "problem_statement": {
      "description": "Find the node where two linked lists intersect.",
      "constraints": [
        "No cycles"
      ],
      "input_format": "ListA, ListB.",
      "output_format": "Intersected Node Value or null.",
      "example": {
        "input": "intersectVal = 8\nListA = [4,1,8,4,5], ListB = [5,6,1,8,4,5]",
        "output": "8",
        "explanation": "Intersect at 8."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "ListA=[1,2], ListB=[3,4]",
        "expected_output": "null",
        "explanation": "No intersection",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "ListA=[1], ListB=[1]",
        "expected_output": "1",
        "explanation": "Same node",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "ListA=[2,6,4], ListB=[1,5]",
        "expected_output": "null",
        "explanation": "Distinct",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Naive: Compare every node A with every node B. O(N*M).",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Better: Use Hash Set to store nodes of A. O(N+M) space.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Optimal: Calculate lengths L1 and L2.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Advance pointer of longer list by |L1-L2| steps, then move together.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N+M)",
      "space_complexity": "O(1)",
      "optimal_approach": "Length Difference."
    }
  },
  {
    "problem_id": "Q071",
    "metadata": {
      "week": 3,
      "day": 4,
      "topic": "Stack",
      "title": "Stack Implementation using Array",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Stack Operations"
      ]
    },
    "problem_statement": {
      "description": "Implement a Stack using an Array with push, pop, top, and isEmpty operations.",
      "constraints": [
        "Capacity 1000"
      ],
      "input_format": "Series of commands.",
      "output_format": "Results of operations.",
      "example": {
        "input": "push 1, push 2, pop, top",
        "output": "2, 1",
        "explanation": "Popped 2, Top is 1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "push 5, top",
        "expected_output": "5",
        "explanation": "Push and Peek",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "pop",
        "expected_output": "Underflow",
        "explanation": "Empty pop",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "push 1, push 2, pop, top",
        "expected_output": "1",
        "explanation": "Standard",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use an array and a top pointer.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Initialize top = -1.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 3,
        "hint_text": "Push: arr[++top] = val.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Pop: return arr[top--]. Check for underflow.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1) for all ops",
      "space_complexity": "O(N)",
      "optimal_approach": "Array."
    }
  },
  {
    "problem_id": "Q072",
    "metadata": {
      "week": 3,
      "day": 4,
      "topic": "Queue",
      "title": "Queue Implementation using Array",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Queue Operations"
      ]
    },
    "problem_statement": {
      "description": "Implement a Queue using an Array with enqueue, dequeue, front operations.",
      "constraints": [
        "Capacity 1000"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "enq 1, enq 2, deq, front",
        "output": "1, 2",
        "explanation": "Dequeued 1, Front is 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "enq 5, front",
        "expected_output": "5",
        "explanation": "Standard",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "deq",
        "expected_output": "Underflow",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "enq 1, deq, enq 2, front",
        "expected_output": "2",
        "explanation": "Basic flow",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use front and rear pointers.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Enqueue adds at rear.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 3,
        "hint_text": "Dequeue increments front.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Handle generic array queue (drifting) or circular queue for efficiency.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(N)",
      "optimal_approach": "Circular Buffer."
    }
  },
  {
    "problem_id": "Q073",
    "metadata": {
      "week": 3,
      "day": 4,
      "topic": "Stack",
      "title": "Stack using Linked List",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Dynamic Stack"
      ]
    },
    "problem_statement": {
      "description": "Implement Stack using Linked List.",
      "constraints": [
        "Dynamic Size"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "push 1, pop",
        "output": "1",
        "explanation": "Popped 1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "push 10, top",
        "expected_output": "10",
        "explanation": "Basic",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "size",
        "expected_output": "0",
        "explanation": "Empty stats",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "push 1, push 2, pop, top",
        "expected_output": "1",
        "explanation": "Correct LIFO",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Insert at head for O(1) push.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Delete at head for O(1) pop.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Head pointer acts as Top.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 4,
        "hint_text": "Check for null on pop.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(N)",
      "optimal_approach": "LL Head insertion."
    }
  },
  {
    "problem_id": "Q074",
    "metadata": {
      "week": 3,
      "day": 4,
      "topic": "Queue",
      "title": "Queue using Linked List",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Dynamic Queue"
      ]
    },
    "problem_statement": {
      "description": "Implement Queue using Linked List.",
      "constraints": [
        "Dynamic Size"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "enq 1, enq 2, deq",
        "output": "1",
        "explanation": "FIFO."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "enq 10, front",
        "expected_output": "10",
        "explanation": "Basic",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "deq",
        "expected_output": "null",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "enq 1, deq, front",
        "expected_output": "null",
        "explanation": "Empty after deq",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Need Head (Front) and Tail (Rear) pointers.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Enqueue: Add at Tail. Update Tail.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Dequeue: Remove Head. Update Head.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If Head becomes null, set Tail to null too.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(N)",
      "optimal_approach": "LL with Tail pointer."
    }
  },
  {
    "problem_id": "Q075",
    "metadata": {
      "week": 3,
      "day": 5,
      "topic": "Stack",
      "title": "Min Stack",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Flipkart"
      ],
      "learning_outcomes": [
        "O(1) Retrieval"
      ]
    },
    "problem_statement": {
      "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
      "constraints": [
        "O(1) for getMin"
      ],
      "input_format": "Commands.",
      "output_format": "Outputs.",
      "example": {
        "input": "push -2, push 0, push -3, getMin, pop, top, getMin",
        "output": "-3, 0, -2",
        "explanation": "Min sequence."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "push 1, min",
        "expected_output": "1",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "push 2, push 1, min",
        "expected_output": "1",
        "explanation": "New min",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "push 1, push 2, min",
        "expected_output": "1",
        "explanation": "Old min retained",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use an auxiliary stack to store minimums.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "On push(x), push x to main stack. Push min(x, minStack.top) to min stack.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "On pop, pop both.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Optimization: Only push to minStack if x <= currentMin.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(N)",
      "optimal_approach": "Auxiliary Stack."
    }
  },
  {
    "problem_id": "Q076",
    "metadata": {
      "week": 3,
      "day": 5,
      "topic": "Stack",
      "title": "Evaluate Reverse Polish Notation",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Google",
        "LinkedIn"
      ],
      "learning_outcomes": [
        "Postfix Evaluation"
      ]
    },
    "problem_statement": {
      "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation (Postfix).",
      "constraints": [
        "Valid Expression"
      ],
      "input_format": "Array of strings (tokens).",
      "output_format": "Integer result.",
      "example": {
        "input": "2 1 + 3 *",
        "output": "9",
        "explanation": "(2+1)*3 = 9"
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4 13 5 / +",
        "expected_output": "6",
        "explanation": "4 + (13/5) = 4+2=6",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "10 6 9 3 + -11 * / * 17 + 5 +",
        "expected_output": "22",
        "explanation": "Complex",
        "category": "complex"
      },
      {
        "tc_id": "TC003",
        "input": "3 4 +",
        "expected_output": "7",
        "explanation": "Simple",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Scan from left to right.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "If number, push to stack.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If operator, pop two numbers, apply op, push result.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Order of operands for - and / matters: op2 is top, op1 is below.",
        "hint_type": "common_mistake"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Stack."
    }
  },
  {
    "problem_id": "Q077",
    "metadata": {
      "week": 3,
      "day": 5,
      "topic": "Stack",
      "title": "Next Greater Element II",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google"
      ],
      "learning_outcomes": [
        "Monotonic Stack",
        "Circular Array"
      ]
    },
    "problem_statement": {
      "description": "Find Next Greater Element for every element in a circular array.",
      "constraints": [
        "1 <= N <= 10000"
      ],
      "input_format": "N, Array.",
      "output_format": "Array of NGE.",
      "example": {
        "input": "1 2 1",
        "output": "2 -1 2",
        "explanation": "NGE of last 1 is 2 (circular)."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 2 1",
        "expected_output": "-1 3 3",
        "explanation": "Circular check",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 2 3",
        "expected_output": "2 3 -1",
        "explanation": "Increasing",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1 1",
        "expected_output": "-1 -1",
        "explanation": "Same",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Monotonic Decreasing Stack stores indices.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Circular array can be simulated by iterating 2*N times.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Use index i % N.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Only update result for i < N.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Stack with Modulo."
    }
  },
  {
    "problem_id": "Q078",
    "metadata": {
      "week": 3,
      "day": 5,
      "topic": "Stack",
      "title": "Sort a Stack",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Recursion"
      ]
    },
    "problem_statement": {
      "description": "Sort values in a stack using recursion (or temporary stack).",
      "constraints": [
        "Recursion or Aux Stack allowed"
      ],
      "input_format": "Stack elements.",
      "output_format": "Sorted Stack.",
      "example": {
        "input": "3 1 2 (Top is 2)",
        "output": "1 2 3 (Top is 3)",
        "explanation": "Sorted."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 2 1",
        "expected_output": "1 2 3",
        "explanation": "Reverse",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 2 3",
        "expected_output": "1 2 3",
        "explanation": "Sorted",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Pop out top element.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Recursively sort remaining stack.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Insert the popped element into sorted stack.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Sorted Insert: recursive function that pops until it finds correct spot.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(N) stack",
      "optimal_approach": "Recursion."
    }
  },
  {
    "problem_id": "Q079",
    "metadata": {
      "week": 3,
      "day": 5,
      "topic": "Queue",
      "title": "Implement Queue using Stacks",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Microsoft",
        "Google"
      ],
      "learning_outcomes": [
        "Stack to Queue"
      ]
    },
    "problem_statement": {
      "description": "Implement Queue using two Stacks.",
      "constraints": [
        "Two Stacks"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "enq 1, enq 2, deq",
        "output": "1",
        "explanation": "FIFO."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "enq 1, enq 2, top",
        "expected_output": "1",
        "explanation": "Peek",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "deq",
        "expected_output": "Empty",
        "explanation": "Underflow",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "enq 1, deq, enq 2, deq",
        "expected_output": "1, 2",
        "explanation": "Sequence",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use two stacks: input and output.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Enqueue: Push to input stack.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 3,
        "hint_text": "Dequeue: Pop from output stack. If output empty, move all from input to output.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Amortized complexity is O(1).",
        "hint_type": "interview"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1) amortized",
      "space_complexity": "O(N)",
      "optimal_approach": "Two Stacks."
    }
  },
  {
    "problem_id": "Q080",
    "metadata": {
      "week": 3,
      "day": 5,
      "topic": "Stack",
      "title": "Implement Stack using Queues",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Queue to Stack"
      ]
    },
    "problem_statement": {
      "description": "Implement Stack using Queues.",
      "constraints": [
        "One or Two Queues"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "push 1, push 2, pop",
        "output": "2",
        "explanation": "LIFO."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "push 10, top",
        "expected_output": "10",
        "explanation": "Basic",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "pop",
        "expected_output": "Empty",
        "explanation": "Edge",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "push 1, push 2, push 3, pop",
        "expected_output": "3",
        "explanation": "LIFO",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Method 1: Two Queues. Push is O(1), Pop is O(N).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Method 2: One Queue. Push O(N), Pop O(1).",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "For One Queue: On push, enqueue x, then dequeue and enqueue all previous elements.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "This rotates the queue so new element is at front.",
        "hint_type": "complexity"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N) push, O(1) pop",
      "space_complexity": "O(N)",
      "optimal_approach": "One Queue."
    }
  },
  {
    "problem_id": "Q081",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Backtracking",
      "title": "Generate Parentheses",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Backtracking",
        "Recursion"
      ]
    },
    "problem_statement": {
      "description": "Generate all combinations of well-formed parentheses for N pairs.",
      "constraints": [
        "1 <= N <= 8"
      ],
      "input_format": "Integer N.",
      "output_format": "List of strings.",
      "example": {
        "input": "3",
        "output": "((())), (()()), (())(), ()(()), ()()()",
        "explanation": "All valid."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "()",
        "explanation": "Basic",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2",
        "expected_output": "(()), ()()",
        "explanation": "Two pairs",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "0",
        "expected_output": "",
        "explanation": "Empty",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Keep track of open and close counts.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Recursive function(current_string, open, close).",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If open < N, add '('.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If close < open, add ')'. Base case: len == 2*N.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(4^N / sqrt(N))",
      "space_complexity": "O(N)",
      "optimal_approach": "Backtracking."
    }
  },
  {
    "problem_id": "Q082",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Backtracking",
      "title": "Letter Combinations of a Phone Number",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Facebook"
      ],
      "learning_outcomes": [
        "Mapping",
        "Recursion"
      ]
    },
    "problem_statement": {
      "description": "Given a digit string, return all possible letter combinations (like old mobile keypad).",
      "constraints": [
        "0 <= Length <= 4",
        "Digits 2-9"
      ],
      "input_format": "String digits.",
      "output_format": "List of strings.",
      "example": {
        "input": "23",
        "output": "ad ae af bd be bf cd ce cf",
        "explanation": "2->abc, 3->def."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2",
        "expected_output": "a b c",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "",
        "explanation": "Empty input",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "9",
        "expected_output": "w x y z",
        "explanation": "4 chars",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Map '2' to 'abc', '3' to 'def', etc.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterate through the string.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "For each digit, loop through its mapped letters and append to combinations of previous digits.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Depth First Search (Backtracking) is natural here.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(4^N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Backtracking."
    }
  },
  {
    "problem_id": "Q083",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Backtracking",
      "title": "Permutations",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "LinkedIn",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Permutations"
      ]
    },
    "problem_statement": {
      "description": "Given an array of distinct integers, return all possible permutations.",
      "constraints": [
        "1 <= N <= 6"
      ],
      "input_format": "Array nums.",
      "output_format": "List of lists.",
      "example": {
        "input": "1 2 3",
        "output": "[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]",
        "explanation": "6 perms."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2",
        "expected_output": "1 2, 2 1",
        "explanation": "2 perms",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0 1",
        "expected_output": "0 1, 1 0",
        "explanation": "With zero",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use backtracking.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Keep track of visited elements or valid choices.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Swap element at current index with every subsequent index.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Recurse and then backtrack (swap back).",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N!)",
      "space_complexity": "O(N)",
      "optimal_approach": "Backtracking."
    }
  },
  {
    "problem_id": "Q084",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Backtracking",
      "title": "Subsets",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Amazon"
      ],
      "learning_outcomes": [
        "Power Set"
      ]
    },
    "problem_statement": {
      "description": "Given an integer array of unique elements, return all possible subsets (the power set).",
      "constraints": [
        "1 <= N <= 10"
      ],
      "input_format": "Array nums.",
      "output_format": "List of lists.",
      "example": {
        "input": "1 2 3",
        "output": "[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]",
        "explanation": "All subsets."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0",
        "expected_output": "[], [0]",
        "explanation": "Subsets",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 2",
        "expected_output": "[], [1], [2], [1,2]",
        "explanation": "Subsets",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "",
        "expected_output": "[]",
        "explanation": "Empty set",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Backtracking: Include element or Exclude element.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterative: Start with [[]]. For each num, add it to all existing subsets.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 3,
        "hint_text": "Bit manipulation: Iterate 0 to 2^N - 1. Use bits to select elements.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Total 2^N subsets.",
        "hint_type": "complexity"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(2^N * N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Cascading."
    }
  },
  {
    "problem_id": "Q085",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Backtracking",
      "title": "Combination Sum",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Airbnb",
        "Amazon"
      ],
      "learning_outcomes": [
        "Recursion Tree"
      ]
    },
    "problem_statement": {
      "description": "Find all unique combinations in candidates where sum equals target. Repeated use allowed.",
      "constraints": [
        "2 <= target <= 40"
      ],
      "input_format": "Array candidates, Target.",
      "output_format": "List of lists.",
      "example": {
        "input": "2 3 6 7, 7",
        "output": "[7], [2,2,3]",
        "explanation": "Valid sums."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 3 5, 8",
        "expected_output": "[2,2,2,2], [2,3,3], [3,5]",
        "explanation": "Combinations",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2, 1",
        "expected_output": "",
        "explanation": "None",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1, 1",
        "expected_output": "[1]",
        "explanation": "Single",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Sort candidates first to optimize.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 2,
        "hint_text": "DFS(index, current_sum, current_list).",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If sum == target, add list to result.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If sum > target, return. Else iterate from 'index' (re-use allowed).",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(2^Target)",
      "space_complexity": "O(Target)",
      "optimal_approach": "Backtracking."
    }
  },
  {
    "problem_id": "Q086",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Linked List",
      "title": "Add Two Numbers",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Digit Math",
        "LL Traversal"
      ]
    },
    "problem_statement": {
      "description": "You are given two non-empty linked lists representing two non-negative integers (digits in reverse order). Add them and return as LL.",
      "constraints": [
        "0 <= Size <= 100",
        "0 <= NodeVal <= 9"
      ],
      "input_format": "L1, L2.",
      "output_format": "Sum LL.",
      "example": {
        "input": "2-4-3 (342), 5-6-4 (465)",
        "output": "7-0-8 (807)",
        "explanation": "342 + 465 = 807."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0, 0",
        "expected_output": "0",
        "explanation": "Zero sum",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "9-9, 1",
        "expected_output": "0-0-1",
        "explanation": "Carry over",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2, 3",
        "expected_output": "5",
        "explanation": "Simple",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Initialize carry = 0.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Traverse both lists.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Sum = v1 + v2 + carry. New val = Sum % 10. Carry = Sum / 10.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Don't forget carry after last node.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(max(N,M))",
      "space_complexity": "O(max(N,M))",
      "optimal_approach": "One Pass."
    }
  },
  {
    "problem_id": "Q087",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Linked List",
      "title": "Swap Nodes in Pairs",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Microsoft"
      ],
      "learning_outcomes": [
        "Pointer Swapping"
      ]
    },
    "problem_statement": {
      "description": "Swap every two adjacent nodes in a linked list.",
      "constraints": [
        "0 <= N <= 100"
      ],
      "input_format": "List.",
      "output_format": "Modified List.",
      "example": {
        "input": "1 2 3 4",
        "output": "2 1 4 3",
        "explanation": "Pairs swapped."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "1",
        "explanation": "No pair",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "1 2 3",
        "expected_output": "2 1 3",
        "explanation": "Third left alone",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "",
        "expected_output": "",
        "explanation": "Empty",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Recursive approach is cleaner: head.next = swapPairs(head.next.next).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterative: Use dummy node.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Need to track prev, first, second pointers.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Perform 3 pointer updates.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1) iterative",
      "optimal_approach": "Recursive or Iterative."
    }
  },
  {
    "problem_id": "Q088",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Stack",
      "title": "Daily Temperatures",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Self-Driving Car",
        "Google"
      ],
      "learning_outcomes": [
        "Monotonic Stack"
      ]
    },
    "problem_statement": {
      "description": "Given temperatures, return array showing number of days to wait for a warmer temperature.",
      "constraints": [
        "1 <= N <= 10^5"
      ],
      "input_format": "Temps array.",
      "output_format": "Wait days array.",
      "example": {
        "input": "73 74 75 71 69 72 76 73",
        "output": "1 1 4 2 1 1 0 0",
        "explanation": "Days to wait."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "30 40 50 60",
        "expected_output": "1 1 1 0",
        "explanation": "Increasing",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "30 60 90",
        "expected_output": "1 1 0",
        "explanation": "Increasing",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "30 20 10",
        "expected_output": "0 0 0",
        "explanation": "Decreasing",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Similar to Next Greater Element.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Store indices in stack.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If curr > temp[stack.top()], pop and calculate diff = currIndex - stackIndex.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Process elements until stack is monotonic decreasing.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Monotonic Stack."
    }
  },
  {
    "problem_id": "Q089",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Backtracking",
      "title": "Remove Invalid Parentheses",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 35,
      "category": "DSA",
      "company_tags": [
        "Facebook"
      ],
      "learning_outcomes": [
        "BFS for Shortest Path"
      ]
    },
    "problem_statement": {
      "description": "Remove minimum number of invalid parentheses to make valid. Return all possible results.",
      "constraints": [
        "1 <= Length <= 25"
      ],
      "input_format": "String S.",
      "output_format": "List of strings.",
      "example": {
        "input": "()())()",
        "output": "()()(), (())()",
        "explanation": "Remove one )."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "(a)())()",
        "expected_output": "(a)()(), (a())()",
        "explanation": "Chars included",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": ")(",
        "expected_output": "",
        "explanation": "Empty string is valid",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "(()",
        "expected_output": "()",
        "explanation": "Remove one",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "BFS ensures minimum removals (shortest path).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Valid paren check helper function.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 3,
        "hint_text": "Queue storing strings. Start with input.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Generate adjacent states by removing 1 char. Avoid duplicates (Set).",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(2^N)",
      "space_complexity": "O(N)",
      "optimal_approach": "BFS."
    }
  },
  {
    "problem_id": "Q090",
    "metadata": {
      "week": 3,
      "day": 6,
      "topic": "Queue",
      "title": "Sliding Window Maximum",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 30,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Amazon"
      ],
      "learning_outcomes": [
        "Deque"
      ]
    },
    "problem_statement": {
      "description": "Return max element in each sliding window of size k.",
      "constraints": [
        "1 <= k <= N <= 10^5"
      ],
      "input_format": "N, Array, K.",
      "output_format": "Max array.",
      "example": {
        "input": "8\n1 3 -1 -3 5 3 6 7\n3",
        "output": "3 3 5 5 6 7",
        "explanation": "Max in each window."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1\n1\n1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "3\n1 -1 1\n1",
        "expected_output": "1 -1 1",
        "explanation": "K=1",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "3\n4 2 1\n3",
        "expected_output": "4",
        "explanation": "Decreasing",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use Deque (Doubly Ended Queue).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Store indices of useful elements.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "Maintain strictly decreasing order in deque.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Remove indices out of window from front. Max is always at front.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(k)",
      "optimal_approach": "Monotonic Deque."
    }
  },
  {
    "problem_id": "Q091",
    "metadata": {
      "week": 4,
      "day": 1,
      "topic": "Tree",
      "title": "Binary Tree Inorder Traversal",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Tree Traversal"
      ]
    },
    "problem_statement": {
      "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
      "constraints": [
        "0 <= Nodes <= 100"
      ],
      "input_format": "Root node.",
      "output_format": "List of values.",
      "example": {
        "input": "1-null-2-3 (1, null, 2, 3)",
        "output": "1 3 2",
        "explanation": "Left, Root, Right."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 3",
        "expected_output": "2 1 3",
        "explanation": "Full",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Inorder: Left -> Root -> Right.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use recursion.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Base case: if root is null, return.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Iterative approach uses a Stack.",
        "hint_type": "interview"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Recursive/Iterative."
    }
  },
  {
    "problem_id": "Q092",
    "metadata": {
      "week": 4,
      "day": 1,
      "topic": "Tree",
      "title": "Level Order Traversal",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "BFS"
      ]
    },
    "problem_statement": {
      "description": "Return the level order traversal of a binary tree's nodes (i.e., from left to right, level by level).",
      "constraints": [
        "0 <= Nodes <= 2000"
      ],
      "input_format": "Root node.",
      "output_format": "List of lists.",
      "example": {
        "input": "3 9 20 null null 15 7",
        "output": "[3], [9,20], [15,7]",
        "explanation": "Levels."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "[1]",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "[]",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 3",
        "expected_output": "[1], [2,3]",
        "explanation": "Full",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use Breadth First Search (BFS).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Use a Queue.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Loop while queue not empty. Get size of queue (nodes in current level).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Process 'size' nodes, adding their children to queue.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "BFS with Queue."
    }
  },
  {
    "problem_id": "Q093",
    "metadata": {
      "week": 4,
      "day": 1,
      "topic": "Tree",
      "title": "Maximum Depth of Binary Tree",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "LinkedIn"
      ],
      "learning_outcomes": [
        "Recursion Height"
      ]
    },
    "problem_statement": {
      "description": "Find the maximum depth (height) of a binary tree.",
      "constraints": [
        "0 <= Nodes <= 10^4"
      ],
      "input_format": "Root.",
      "output_format": "Integer Depth.",
      "example": {
        "input": "3 9 20 null null 15 7",
        "output": "3",
        "explanation": "3 levels."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2",
        "expected_output": "2",
        "explanation": "Root + Child",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "0",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 3 4",
        "expected_output": "3",
        "explanation": "Height 3",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Recursive approach: max(left, right) + 1.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Base case: if node is null, return 0.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Iterative approach uses BFS (count levels) or DFS.",
        "hint_type": "approach"
      },
      {
        "hint_level": 4,
        "hint_text": "Recursive is simpler.",
        "hint_type": "recommendation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "Recursion."
    }
  },
  {
    "problem_id": "Q094",
    "metadata": {
      "week": 4,
      "day": 2,
      "topic": "Tree",
      "title": "Symmetric Tree",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Google"
      ],
      "learning_outcomes": [
        "Tree Mirror"
      ]
    },
    "problem_statement": {
      "description": "Check if a binary tree is a mirror image of itself (symmetric around center).",
      "constraints": [
        "0 <= Nodes <= 1000"
      ],
      "input_format": "Root.",
      "output_format": "True or False.",
      "example": {
        "input": "1 2 2 3 4 4 3",
        "output": "True",
        "explanation": "Symmetric."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2 2 null 3 null 3",
        "expected_output": "False",
        "explanation": "Not mirror",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "True",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 2",
        "expected_output": "True",
        "explanation": "Simple",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Compare left subtree with right subtree.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Helper function(node1, node2).",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Check: node1.val == node2.val AND mirror(n1.left, n2.right) AND mirror(n1.right, n2.left).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Both null is true. One null is false.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "Recursive Mirror."
    }
  },
  {
    "problem_id": "Q095",
    "metadata": {
      "week": 4,
      "day": 2,
      "topic": "Tree",
      "title": "Invert Binary Tree",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Homebrew"
      ],
      "learning_outcomes": [
        "Tree Modification"
      ]
    },
    "problem_statement": {
      "description": "Invert a binary tree (mirror it).",
      "constraints": [
        "0 <= Nodes <= 100"
      ],
      "input_format": "Root.",
      "output_format": "Root of inverted tree.",
      "example": {
        "input": "4 2 7 1 3 6 9",
        "output": "4 7 2 9 6 3 1",
        "explanation": "Swapped."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 1 3",
        "expected_output": "2 3 1",
        "explanation": "Swapped",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2",
        "expected_output": "1 null 2",
        "explanation": "Left becomes right",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Recursive approach.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Swap left and right children for current node.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Recursively call invert on new left and new right.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Return root.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "Post-order Inversion."
    }
  },
  {
    "problem_id": "Q096",
    "metadata": {
      "week": 4,
      "day": 2,
      "topic": "Tree",
      "title": "Validate Binary Search Tree",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Facebook"
      ],
      "learning_outcomes": [
        "BST Properties"
      ]
    },
    "problem_statement": {
      "description": "Determine if a binary tree is a valid Binary Search Tree (BST).",
      "constraints": [
        "Nodes <= 10^4"
      ],
      "input_format": "Root.",
      "output_format": "True or False.",
      "example": {
        "input": "2 1 3",
        "output": "True",
        "explanation": "Valid."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 1 4",
        "expected_output": "False",
        "explanation": "4 on right is < 5, but its children might be wrong",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 2 2",
        "expected_output": "False",
        "explanation": "Duplicates not allowed (strict inequality)",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5 1 6 3 4",
        "expected_output": "False",
        "explanation": "3 is in right subtree of 5 but is < 5 (BST prop violated)",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Inorder traversal of BST should be sorted.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Alternatively pass range (min, max) to recursion.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Left child must be in (min, parent). Right child in (parent, max).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Use Long or Null for infinite boundaries initially.",
        "hint_type": "edge_case"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "Range Validation."
    }
  },
  {
    "problem_id": "Q097",
    "metadata": {
      "week": 4,
      "day": 3,
      "topic": "Tree",
      "title": "Search in a Binary Search Tree",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "BST Traversal"
      ]
    },
    "problem_statement": {
      "description": "Find the node in the BST that equals the given value.",
      "constraints": [
        "BST structure"
      ],
      "input_format": "Root, Value.",
      "output_format": "Subtree rooted at node or null.",
      "example": {
        "input": "4 2 7 1 3, 2",
        "output": "2 1 3",
        "explanation": "Found 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4 2 7 1 3, 5",
        "expected_output": "null",
        "explanation": "Not found",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "4, 4",
        "expected_output": "4",
        "explanation": "Root",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4 2 7, 7",
        "expected_output": "7",
        "explanation": "Leaf",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "If val < root.val, go left.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "If val > root.val, go right.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "Else return root.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If null, not found.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(H) or O(log N)",
      "space_complexity": "O(1) iterative",
      "optimal_approach": "Binary Search Logic."
    }
  },
  {
    "problem_id": "Q098",
    "metadata": {
      "week": 4,
      "day": 3,
      "topic": "Tree",
      "title": "Lowest Common Ancestor of a BST",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "BST Properties",
        "LCA"
      ]
    },
    "problem_statement": {
      "description": "Find LCA of two nodes P and Q in a BST.",
      "constraints": [
        "All unique values"
      ],
      "input_format": "Root, P, Q.",
      "output_format": "LCA Node.",
      "example": {
        "input": "6 2 8 0 4 7 9..., 2, 8",
        "output": "6",
        "explanation": "Split occurs at 6."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "6 2 8 0 4 7 9, 2, 4",
        "expected_output": "2",
        "explanation": "2 is parent of 4",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 1, 1, 2",
        "expected_output": "2",
        "explanation": "Root",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5 3 6, 3, 6",
        "expected_output": "5",
        "explanation": "Split",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "In BST, LCA is the separation point.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "If both P and Q are smaller than root, go left.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If both are larger, go right.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Else, root is the LCA (split point).",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(H)",
      "space_complexity": "O(1) iterative",
      "optimal_approach": "BST Split Logic."
    }
  },
  {
    "problem_id": "Q099",
    "metadata": {
      "week": 4,
      "day": 3,
      "topic": "Tree",
      "title": "Kth Smallest Element in a BST",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Uber",
        "Google"
      ],
      "learning_outcomes": [
        "Inorder Traversal"
      ]
    },
    "problem_statement": {
      "description": "Find the Kth smallest element in a BST.",
      "constraints": [
        "1 <= K <= N"
      ],
      "input_format": "Root, K.",
      "output_format": "Integer Value.",
      "example": {
        "input": "3 1 4 null 2, 1",
        "output": "1",
        "explanation": "1 is smallest."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5 3 6 2 4 null null 1, 3",
        "expected_output": "3",
        "explanation": "Sorted: 1,2,3,4,5,6",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1, 1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2 1, 2",
        "expected_output": "2",
        "explanation": "Max",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Inorder traversal visits nodes in sorted order.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Traverse Inorder and decrement K.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "When K reaches 0, current node is result.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Stop traversal after finding result.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N) (or O(H+K))",
      "space_complexity": "O(H)",
      "optimal_approach": "Inorder Traversal."
    }
  },
  {
    "problem_id": "Q100",
    "metadata": {
      "week": 4,
      "day": 3,
      "topic": "Tree",
      "title": "Construct BST from Preorder Traversal",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Facebook"
      ],
      "learning_outcomes": [
        "Tree Construction"
      ]
    },
    "problem_statement": {
      "description": "Construct a BST from an array representing its preorder traversal.",
      "constraints": [
        "1 <= N <= 100"
      ],
      "input_format": "Preorder Array.",
      "output_format": "Root of BST.",
      "example": {
        "input": "8 5 1 7 10 12",
        "output": "8 5 10 1 7 null 12",
        "explanation": "BST formed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 3",
        "expected_output": "1 null 3",
        "explanation": "Root 1, Right 3",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "8",
        "expected_output": "8",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "8 5 7 10",
        "expected_output": "8 5 10 null 7",
        "explanation": "Nested",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "First element is root.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Next elements smaller than root go to left.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Elements larger go to right.",
        "hint_type": "approach"
      },
      {
        "hint_level": 4,
        "hint_text": "Use recursion with bounds (min, max).",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Bound Recursion."
    }
  },
  {
    "problem_id": "Q101",
    "metadata": {
      "week": 4,
      "day": 4,
      "topic": "Tree",
      "title": "Path Sum",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Recursion"
      ]
    },
    "problem_statement": {
      "description": "Given a binary tree and a target sum, determine if the tree has a root-to-leaf path sum equal to target.",
      "constraints": [
        "Nodes <= 5000"
      ],
      "input_format": "Root, TargetSum.",
      "output_format": "True or False.",
      "example": {
        "input": "5 4 8 11 null 13 4 7 2 null null null 1, 22",
        "output": "True",
        "explanation": "5+4+11+2 = 22."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2 3, 5",
        "expected_output": "False",
        "explanation": "Paths 3 (1+2), 4 (1+3)",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 2, 0",
        "expected_output": "False",
        "explanation": "Min sum 3",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2, 3",
        "expected_output": "True",
        "explanation": "1+2=3",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Subtract generic node value from target as you go down.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Base case: if Leaf, check if target == val.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Recursive step: pathSum(left, target-val) OR pathSum(right, target-val).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If node is null return false.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "DFS."
    }
  },
  {
    "problem_id": "Q102",
    "metadata": {
      "week": 4,
      "day": 4,
      "topic": "Tree",
      "title": "Path Sum II",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Bloomberg"
      ],
      "learning_outcomes": [
        "Backtracking on Tree"
      ]
    },
    "problem_statement": {
      "description": "Return all root-to-leaf paths where sum equals target.",
      "constraints": [
        "Nodes <= 5000"
      ],
      "input_format": "Root, TargetSum.",
      "output_format": "List of paths.",
      "example": {
        "input": "5 4 8... (Same as Q101), 22",
        "output": "[5,4,11,2], [5,8,4,5]",
        "explanation": "All valid paths."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2 3, 5",
        "expected_output": "[]",
        "explanation": "No paths",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1, 1",
        "expected_output": "[1]",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5 4 8 11 null 13 4 7 2 5 1, 22",
        "expected_output": "[5,4,11,2], [5,8,4,5]",
        "explanation": "Multiple paths",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Keep current path list.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Push node to path list.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Recurse left and right.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Backtrack: Remove node from path list before returning.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "DFS + Backtracking."
    }
  },
  {
    "problem_id": "Q103",
    "metadata": {
      "week": 4,
      "day": 4,
      "topic": "Tree",
      "title": "Diameter of Binary Tree",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Google"
      ],
      "learning_outcomes": [
        "Height Calculation"
      ]
    },
    "problem_statement": {
      "description": "Length of longest path between any two nodes. Path may not pass through root.",
      "constraints": [
        "Nodes <= 10000"
      ],
      "input_format": "Root.",
      "output_format": "Integer Diameter.",
      "example": {
        "input": "1 2 3 4 5",
        "output": "3",
        "explanation": "Path 4-2-1-3 or 5-2-1-3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2",
        "expected_output": "1",
        "explanation": "Path 2-1",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "0",
        "explanation": "No edge",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 3 4 5 null null 6 null 7",
        "expected_output": "4",
        "explanation": "6-4-2-5-7",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "For each node, diameter through it is height(left) + height(right).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Calculate height of each node.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Update global max diameter during height calculation.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Return height (max(L,R)+1) to parent.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "Post-order traversal."
    }
  },
  {
    "problem_id": "Q104",
    "metadata": {
      "week": 4,
      "day": 4,
      "topic": "Tree",
      "title": "Balanced Binary Tree",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Tree Height"
      ]
    },
    "problem_statement": {
      "description": "Check if a binary tree is height-balanced (depth of subtrees differ by at most 1).",
      "constraints": [
        "Nodes <= 5000"
      ],
      "input_format": "Root.",
      "output_format": "True or False.",
      "example": {
        "input": "3 9 20 null null 15 7",
        "output": "True",
        "explanation": "Balanced."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2 2 3 3 null null 4 4",
        "expected_output": "False",
        "explanation": "Unbalanced",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "True",
        "explanation": "Empty is balanced",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2",
        "expected_output": "True",
        "explanation": "Leaning but balanced",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Calculate height of left and right subtrees.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "If |L - R| > 1, return false.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Also recursively check if left and right are balanced.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Can optimize by returning -1 for unbalanced in height function.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(H)",
      "optimal_approach": "Bottom-up Recursion."
    }
  },
  {
    "problem_id": "Q105",
    "metadata": {
      "week": 4,
      "day": 5,
      "topic": "Tree",
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 30,
      "category": "DSA",
      "company_tags": [
        "Uber",
        "Google"
      ],
      "learning_outcomes": [
        "String Formatting",
        "Tree Construction"
      ]
    },
    "problem_statement": {
      "description": "Design an algorithm to serialize a tree to a string and deserialize it back.",
      "constraints": [
        "Nodes <= 10000"
      ],
      "input_format": "Root (for serialize) / String (for deserialize).",
      "output_format": "String / Root.",
      "example": {
        "input": "1 2 3 null null 4 5",
        "output": "1,2,X,X,3,4,X,X,5,X,X",
        "explanation": "Preorder with X for null."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "1,X,X",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "X",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2",
        "expected_output": "1,2,X,X,X",
        "explanation": "Preorder",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use Preorder traversal.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Include nulls as special character 'X' or 'null'.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "For deserialize, split string by comma.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Use a queue or index pointer to reconstruct recursively.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Preorder with Null markers."
    }
  },
  {
    "problem_id": "Q106",
    "metadata": {
      "week": 4,
      "day": 5,
      "topic": "Graph",
      "title": "Find Center of Star Graph",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Graph Properties"
      ]
    },
    "problem_statement": {
      "description": "Find the center node of a star graph (center connects to all other nodes).",
      "constraints": [
        "3 <= N <= 10^5"
      ],
      "input_format": "Edges list.",
      "output_format": "Center node.",
      "example": {
        "input": "[[1,2], [2,3], [4,2]]",
        "output": "2",
        "explanation": "2 intersects all."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "[[1,2],[5,1],[1,3],[1,4]]",
        "expected_output": "1",
        "explanation": "1 is common",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "[[1,2], [2,3]]",
        "expected_output": "2",
        "explanation": "Only need first two edges",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "[[1,3],[2,3]]",
        "expected_output": "3",
        "explanation": "3 is answer",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Center node must appear in every edge.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Check only the first two edges.",
        "hint_type": "opitmization"
      },
      {
        "hint_level": 3,
        "hint_text": "If u1 == u2 OR u1 == v2, then u1 is center.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Otherwise v1 must be center.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "optimal_approach": "Compare first two edges."
    }
  },
  {
    "problem_id": "Q107",
    "metadata": {
      "week": 4,
      "day": 5,
      "topic": "Graph",
      "title": "BFS of Graph",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "BFS"
      ]
    },
    "problem_statement": {
      "description": "Perform BFS traversal of a graph starting from node 0.",
      "constraints": [
        "N nodes"
      ],
      "input_format": "Adj List.",
      "output_format": "Array of nodes.",
      "example": {
        "input": "0: [1,2], 1:[2], 2:[0,3], 3:[]",
        "output": "0 1 2 3",
        "explanation": "Level order."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0:[1,2],1:[2],2:[]",
        "expected_output": "0 1 2",
        "explanation": "Simple",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0:[]",
        "expected_output": "0",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0:[1],1:[2],2:[3],3:[]",
        "expected_output": "0 1 2 3",
        "explanation": "Line",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use Queue for BFS.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Keep Visited array.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Mark start node visited and enqueue.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "While queue not empty, dequeue u, visit neighbors v. If v not visited, mark and enqueue.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "optimal_approach": "BFS."
    }
  },
  {
    "problem_id": "Q108",
    "metadata": {
      "week": 4,
      "day": 5,
      "topic": "Graph",
      "title": "DFS of Graph",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "DFS"
      ]
    },
    "problem_statement": {
      "description": "Perform DFS traversal starting from node 0 (assume connected or visit components).",
      "constraints": [
        "N nodes"
      ],
      "input_format": "Adj List.",
      "output_format": "Array of nodes.",
      "example": {
        "input": "0: [1,2], 1:[2], 2:[3]",
        "output": "0 1 2 3",
        "explanation": "DFS order."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0:[1,2], 1:[2], 2:[]",
        "expected_output": "0 1 2",
        "explanation": "Depth first",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0:[]",
        "expected_output": "0",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0:[1],1:[0]",
        "expected_output": "0 1",
        "explanation": "Cycle handled by visited",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use recursion or Stack.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Maintain Visited array to avoid cycles.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Visit u, mark visited, then recursively visit all unvisited neighbors.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Print node when visiting.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "optimal_approach": "DFS."
    }
  },
  {
    "problem_id": "Q109",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Number of Islands",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Connected Components"
      ]
    },
    "problem_statement": {
      "description": "Count number of islands in a binary grid (1 is land, 0 is water).",
      "constraints": [
        "Grid size <= 300x300"
      ],
      "input_format": "2D Grid.",
      "output_format": "Integer count.",
      "example": {
        "input": "11000\n11000\n00100\n00011",
        "output": "3",
        "explanation": "Islands."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "111\n010\n111",
        "expected_output": "1",
        "explanation": "All connected",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "000\n000",
        "expected_output": "0",
        "explanation": "No land",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "101\n010\n101",
        "expected_output": "5",
        "explanation": "Diagonal not connected",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Iterate through each cell.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "If cell is '1' and not visited, increment count and trigger traversal.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Traversal (DFS/BFS) marks all connected '1's as visited.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "You can modify grid to '0' to mark visited without extra space.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N)",
      "space_complexity": "O(M*N) or O(min(M,N)) stack",
      "optimal_approach": "DFS/BFS."
    }
  },
  {
    "problem_id": "Q110",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Flood Fill",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Classic"
      ],
      "learning_outcomes": [
        "Matrix Traversal"
      ]
    },
    "problem_statement": {
      "description": "Perform flood fill on an image (start node, new color). Replaces connected pixels of same color.",
      "constraints": [
        "Grid <= 50x50"
      ],
      "input_format": "Image, sr, sc, newColor.",
      "output_format": "Modified Image.",
      "example": {
        "input": "1 1 1\n1 1 0\n1 0 1, sr=1, sc=1, new=2",
        "output": "2 2 2\n2 2 0\n2 0 1",
        "explanation": "Filled."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0 0 0, 0, 0, 1",
        "expected_output": "1 1 1",
        "explanation": "All connected",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 1 1, 1, 1, 1",
        "expected_output": "1 1 1",
        "explanation": "Same color",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 0 1, 0, 0, 2",
        "expected_output": "2 0 1",
        "explanation": "Disconnected",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Get start color.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "If start color == new color, return immediately.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 3,
        "hint_text": "DFS/BFS from (sr, sc).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If neighbor has start color, change to new color and recurse.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N)",
      "space_complexity": "O(M*N)",
      "optimal_approach": "DFS."
    }
  },
  {
    "problem_id": "Q111",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Rotting Oranges",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Multi-source BFS"
      ]
    },
    "problem_statement": {
      "description": "Grid with 0 (empty), 1 (fresh), 2 (rotten). Returns mins until all fresh rot. If impossible return -1.",
      "constraints": [
        "Grid <= 10x10"
      ],
      "input_format": "Grid.",
      "output_format": "Minutes.",
      "example": {
        "input": "2 1 1\n1 1 0\n0 1 1",
        "output": "4",
        "explanation": "Propagation."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 1 1\n0 1 1\n1 0 1",
        "expected_output": "-1",
        "explanation": "Isolated fresh orange",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "0 2",
        "expected_output": "0",
        "explanation": "No fresh oranges",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2 1 1",
        "expected_output": "2",
        "explanation": "Simple",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "BFS starts from ALL rotten oranges simultaneously.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Enqueue all initial '2's.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Count fresh oranges initially.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Decrement fresh count as they rot. If fresh > 0 at end, return -1.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N*M)",
      "space_complexity": "O(N*M)",
      "optimal_approach": "BFS."
    }
  },
  {
    "problem_id": "Q112",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "01 Matrix",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Google"
      ],
      "learning_outcomes": [
        "BFS Distance"
      ]
    },
    "problem_statement": {
      "description": "Given a matrix, find distance of nearest 0 for each cell.",
      "constraints": [
        "10^4 cells"
      ],
      "input_format": "Matrix.",
      "output_format": "Distance Matrix.",
      "example": {
        "input": "0 0 0\n0 1 0\n1 1 1",
        "output": "0 0 0\n0 1 0\n1 2 1",
        "explanation": "Distances."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0 0 0\n0 1 0\n0 0 0",
        "expected_output": "0 0 0\n0 1 0\n0 0 0",
        "explanation": "Surrounded",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 1\n1 0",
        "expected_output": "2 1\n1 0",
        "explanation": "Corner",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0",
        "expected_output": "0",
        "explanation": "Single",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Start BFS from all 0s.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Initialize distances to Infinity for 1s, 0 for 0s.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Update neighbor if new dist < old dist.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "DP approach is also possible (two passes).",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N)",
      "space_complexity": "O(M*N)",
      "optimal_approach": "BFS."
    }
  },
  {
    "problem_id": "Q113",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Surrounded Regions",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Google"
      ],
      "learning_outcomes": [
        "Boundary Traversal"
      ]
    },
    "problem_statement": {
      "description": "Capture all 'O' surrounded by 'X'. (Flip O to X if not connected to boundary O).",
      "constraints": [
        "200x200"
      ],
      "input_format": "Board.",
      "output_format": "Captured Board.",
      "example": {
        "input": "X X X X\nX O O X\nX X O X\nX O X X",
        "output": "X X X X\nX X X X\nX X X X\nX O X X",
        "explanation": "Only boundary O survives."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "X X\nX X",
        "expected_output": "X X\nX X",
        "explanation": "No O",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "O O\nO O",
        "expected_output": "O O\nO O",
        "explanation": "All connected to boundary",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "X X X\nX O X\nX X X",
        "expected_output": "X X X\nX X X\nX X X",
        "explanation": "Captured",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Start from boundary 'O's.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Run DFS/BFS to mark 'Safe' regions (connected to boundary).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "After traversal, flip remaining 'O' to 'X'.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Flip 'Safe' back to 'O'.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N)",
      "space_complexity": "O(M*N)",
      "optimal_approach": "Boundary DFS."
    }
  },
  {
    "problem_id": "Q114",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Clone Graph",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Google"
      ],
      "learning_outcomes": [
        "Deep Copy",
        "Hash Map"
      ]
    },
    "problem_statement": {
      "description": "Deep copy of a connected undirected graph.",
      "constraints": [
        "Ref nodes"
      ],
      "input_format": "Adjacency List.",
      "output_format": "Copied List.",
      "example": {
        "input": "1:[2,4], 2:[1,3], 3:[2,4], 4:[1,3]",
        "output": "Same structure, new objects.",
        "explanation": "Clone."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1:[]",
        "expected_output": "1:[]",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "",
        "expected_output": "",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1:[2], 2:[1]",
        "expected_output": "Clone",
        "explanation": "Two nodes",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Use a Map<OldNode, NewNode> to track visited.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "DFS or BFS traversal.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If neighbor already in map, link to it.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Else create new node, add to map, and recurse.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "optimal_approach": "DFS with Map."
    }
  },
  {
    "problem_id": "Q115",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Course Schedule (Topological Sort)",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon"
      ],
      "learning_outcomes": [
        "Cycle Detection",
        "Topological Sort"
      ]
    },
    "problem_statement": {
      "description": "Can you finish all courses given prerequisites? (Detect cycle in directed graph).",
      "constraints": [
        "NumCourses <= 2000"
      ],
      "input_format": "NumCourses, Prerequisites.",
      "output_format": "True or False.",
      "example": {
        "input": "2, [[1,0]]",
        "output": "True",
        "explanation": "Take 0 then 1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2, [[1,0], [0,1]]",
        "expected_output": "False",
        "explanation": "Cycle",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1, []",
        "expected_output": "True",
        "explanation": "No prereq",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3, [[1,0],[2,1]]",
        "expected_output": "True",
        "explanation": "Chain",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Construct Adjacency List.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Kahn's Algorithm (BFS) using Indegrees.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If queue becomes empty before counting all nodes, there is a cycle.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "DFS with 'recursion stack' check also works.",
        "hint_type": "approach"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V+E)",
      "optimal_approach": "Kahn's Algorithm."
    }
  },
  {
    "problem_id": "Q116",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Heap",
      "title": "Kth Largest Element in an Array",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Amazon"
      ],
      "learning_outcomes": [
        "Priority Queue",
        "Quick Select"
      ]
    },
    "problem_statement": {
      "description": "Find Kth largest element.",
      "constraints": [
        "1 <= K <= N"
      ],
      "input_format": "Array, K.",
      "output_format": "Value.",
      "example": {
        "input": "3 2 1 5 6 4, 2",
        "output": "5",
        "explanation": "Sorted: 1 2 3 4 5 6. 2nd largest is 5."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 2 3 1 2 4 5 5 6, 4",
        "expected_output": "4",
        "explanation": "4th largest",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1, 1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2, 2",
        "expected_output": "1",
        "explanation": "Min",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Sorting O(N log N) is trivial.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Use Min-Heap of size K. Root is Kth largest.",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "Complexity O(N log K).",
        "hint_type": "complexity"
      },
      {
        "hint_level": 4,
        "hint_text": "QuickSelect is O(N) average.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N log K) or O(N)",
      "space_complexity": "O(K)",
      "optimal_approach": "Min-Heap."
    }
  },
  {
    "problem_id": "Q117",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Heap",
      "title": "Top K Frequent Words",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Uber"
      ],
      "learning_outcomes": [
        "Custom Comparator"
      ]
    },
    "problem_statement": {
      "description": "Return K most frequent strings ordered by freq, then lexicographical.",
      "constraints": [
        "N strings"
      ],
      "input_format": "Array words, K.",
      "output_format": "List of strings.",
      "example": {
        "input": "i love leetcode i love coding, 2",
        "output": "i love",
        "explanation": "Highest freq."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "the day is sunny the the the sunny is is, 4",
        "expected_output": "the is sunny day",
        "explanation": "Order by count then alpha",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "a, 1",
        "expected_output": "a",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "a aa, 1",
        "expected_output": "a",
        "explanation": "a before aa (alpha) if counts same (here counts diff)",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Count frequencies using Map.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Use Priority Queue with custom comparator.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Comparator: if freq equal, compare string order.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Or bucket sort if N is small.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N log K)",
      "space_complexity": "O(N)",
      "optimal_approach": "Heap."
    }
  },
  {
    "problem_id": "Q118",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Heap",
      "title": "Find Median from Data Stream",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 35,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Amazon"
      ],
      "learning_outcomes": [
        "Two Heaps Pattern"
      ]
    },
    "problem_statement": {
      "description": "Design class to addNum and findMedian efficiently.",
      "constraints": [
        "Calls <= 10^4"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "add 1, add 2, findMedian, add 3, findMedian",
        "output": "1.5, 2",
        "explanation": "Median of 1,2 is 1.5. Median of 1,2,3 is 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "add 1, find",
        "expected_output": "1",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "add 10, add 20, add 30, add 40, find",
        "expected_output": "25",
        "explanation": "10 20 30 40 -> 25",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "add -1, add -2, find",
        "expected_output": "-1.5",
        "explanation": "Negative",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Maintain sorted order? O(N) insertion.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Use Two Heaps: Max-Heap (left half) and Min-Heap (right half).",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "Balance heaps so size diff is at most 1.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Median is top or avg of tops.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log N) add, O(1) find",
      "space_complexity": "O(N)",
      "optimal_approach": "Two Heaps."
    }
  },
  {
    "problem_id": "Q119",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Heap",
      "title": "Merge K Sorted Lists",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 30,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Divide & Conquer",
        "Heap"
      ]
    },
    "problem_statement": {
      "description": "Merge k linked lists, each sorted, into one sorted list.",
      "constraints": [
        "K <= 10^4"
      ],
      "input_format": "Array of List Heads.",
      "output_format": "Merged Head.",
      "example": {
        "input": "1-4-5, 1-3-4, 2-6",
        "output": "1-1-2-3-4-4-5-6",
        "explanation": "Merged."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "[], []",
        "expected_output": "[]",
        "explanation": "Empty",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "1-2, 3-4",
        "expected_output": "1-2-3-4",
        "explanation": "Two lists",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Min-Heap storing heads of all K lists.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Extract min, add next node of that list to heap.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Divide and Conquer: Pairwise merge.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Pairwise merge is O(N log K) too.",
        "hint_type": "complexity"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N log K)",
      "space_complexity": "O(K)",
      "optimal_approach": "Min-Heap."
    }
  },
  {
    "problem_id": "Q120",
    "metadata": {
      "week": 4,
      "day": 6,
      "topic": "Graph",
      "title": "Find the Town Judge",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Degree Calculation"
      ]
    },
    "problem_statement": {
      "description": "Judge trusts nobody. Everybody trusting Judge. Find Judge index or -1.",
      "constraints": [
        "1 <= N <= 1000"
      ],
      "input_format": "N, Trust array.",
      "output_format": "Judge ID.",
      "example": {
        "input": "2, [[1,2]]",
        "output": "2",
        "explanation": "1 trusts 2."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3, [[1,3],[2,3]]",
        "expected_output": "3",
        "explanation": "Judge 3",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "3, [[1,3],[2,3],[3,1]]",
        "expected_output": "-1",
        "explanation": "3 trusts 1, not judge",
        "category": "complex"
      },
      {
        "tc_id": "TC003",
        "input": "1, []",
        "expected_output": "1",
        "explanation": "Single person is judge",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Calculate indegree and outdegree.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Judge has Indegree N-1 and Outdegree 0.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Use array to store degrees.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Iterate to check condition.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(E+N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Indegree Array."
    }
  },
  {
    "problem_id": "Q121",
    "metadata": {
      "week": 5,
      "day": 1,
      "topic": "Dynamic Programming",
      "title": "Climbing Stairs",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic",
        "Amazon"
      ],
      "learning_outcomes": [
        "DP Basics",
        "Fibonacci"
      ]
    },
    "problem_statement": {
      "description": "Ways to climb N stairs taking 1 or 2 steps at a time.",
      "constraints": [
        "1 <= N <= 45"
      ],
      "input_format": "Integer N.",
      "output_format": "Integer Ways.",
      "example": {
        "input": "3",
        "output": "3",
        "explanation": "1+1+1, 1+2, 2+1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2",
        "expected_output": "2",
        "explanation": "2 ways",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "1 way",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "4",
        "expected_output": "5",
        "explanation": "Ways",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i] = dp[i-1] + dp[i-2].",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Base cases: dp[1]=1, dp[2]=2.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Optimize space to O(1) using two variables.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "It's essentially Fibonacci sequence.",
        "hint_type": "conceptual"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Iterative."
    }
  },
  {
    "problem_id": "Q122",
    "metadata": {
      "week": 5,
      "day": 1,
      "topic": "Dynamic Programming",
      "title": "House Robber",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Google",
        "LinkedIn"
      ],
      "learning_outcomes": [
        "1D DP"
      ]
    },
    "problem_statement": {
      "description": "Max amount you can rob without robbing adjacent houses.",
      "constraints": [
        "N <= 100"
      ],
      "input_format": "Array nums.",
      "output_format": "Max Amount.",
      "example": {
        "input": "1 2 3 1",
        "output": "4",
        "explanation": "1 + 3 = 4."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 7 9 3 1",
        "expected_output": "12",
        "explanation": "2+9+1",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 1",
        "expected_output": "1",
        "explanation": "Max of two",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Decide for house i: rob or skip.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "dp[i] = max(dp[i-1], nums[i] + dp[i-2]).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Handle base cases for i=0, i=1.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Space optimization possible.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Iterative DP."
    }
  },
  {
    "problem_id": "Q123",
    "metadata": {
      "week": 5,
      "day": 1,
      "topic": "Dynamic Programming",
      "title": "Longest Increasing Subsequence",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Microsoft",
        "Google"
      ],
      "learning_outcomes": [
        "LIS Pattern"
      ]
    },
    "problem_statement": {
      "description": "Length of longest strictly increasing subsequence.",
      "constraints": [
        "N <= 2500"
      ],
      "input_format": "Array nums.",
      "output_format": "Integer length.",
      "example": {
        "input": "10 9 2 5 3 7 101 18",
        "output": "4",
        "explanation": "2 3 7 101 or 2 3 7 18."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0 1 0 3 2 3",
        "expected_output": "4",
        "explanation": "0 1 2 3",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "5 5 5",
        "expected_output": "1",
        "explanation": "Strict increasing",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 3",
        "expected_output": "3",
        "explanation": "Full array",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i] = max length ending at index i.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "For j < i, if nums[i] > nums[j], dp[i] = max(dp[i], dp[j]+1).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "O(N^2) solution.",
        "hint_type": "complexity"
      },
      {
        "hint_level": 4,
        "hint_text": "O(N log N) solution using Binary Search exists.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2) or O(N log N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Binary Search Patience Sort."
    }
  },
  {
    "problem_id": "Q124",
    "metadata": {
      "week": 5,
      "day": 2,
      "topic": "Dynamic Programming",
      "title": "Longest Common Subsequence",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "2D DP"
      ]
    },
    "problem_statement": {
      "description": "Length of longest common subsequence of two strings.",
      "constraints": [
        "Length <= 1000"
      ],
      "input_format": "String text1, String text2.",
      "output_format": "Integer length.",
      "example": {
        "input": "abcde, ace",
        "output": "3",
        "explanation": "ace."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "abc, abc",
        "expected_output": "3",
        "explanation": "Same",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "abc, def",
        "expected_output": "0",
        "explanation": "None",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "bl, yby",
        "expected_output": "1",
        "explanation": "b",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i][j] represents LCS of text1[0..i] and text2[0..j].",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "If chars match: 1 + dp[i-1][j-1].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Else: max(dp[i-1][j], dp[i][j-1]).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Grid approach.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N*M)",
      "space_complexity": "O(N*M)",
      "optimal_approach": "2D DP."
    }
  },
  {
    "problem_id": "Q125",
    "metadata": {
      "week": 5,
      "day": 2,
      "topic": "Dynamic Programming",
      "title": "Coin Change",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Uber"
      ],
      "learning_outcomes": [
        "Unbounded Knapsack"
      ]
    },
    "problem_statement": {
      "description": "Fewest number of coins to make up amount using given coins.",
      "constraints": [
        "Coins <= 12",
        "Amount <= 10000"
      ],
      "input_format": "Coins array, Amount.",
      "output_format": "Count or -1.",
      "example": {
        "input": "1 2 5, 11",
        "output": "3",
        "explanation": "5+5+1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2, 3",
        "expected_output": "-1",
        "explanation": "Impossible",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1, 0",
        "expected_output": "0",
        "explanation": "Zero",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1, 2",
        "expected_output": "2",
        "explanation": "1+1",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i] = min coins for amount i.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Initialize dp array with infinity (amount+1). dp[0]=0.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "For each coin c, dp[i] = min(dp[i], dp[i-c] + 1).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If dp[amount] > amount, return -1.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(Amount * Coins)",
      "space_complexity": "O(Amount)",
      "optimal_approach": "Bottom-up DP."
    }
  },
  {
    "problem_id": "Q126",
    "metadata": {
      "week": 5,
      "day": 2,
      "topic": "Array",
      "title": "Maximum Subarray (Kadane's Algorithm)",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Classic"
      ],
      "learning_outcomes": [
        "Kadane's Algo"
      ]
    },
    "problem_statement": {
      "description": "Find contiguous subarray with largest sum.",
      "constraints": [
        "N <= 10^5"
      ],
      "input_format": "Array nums.",
      "output_format": "Max Sum.",
      "example": {
        "input": "-2 1 -3 4 -1 2 1 -5 4",
        "output": "6",
        "explanation": "4 -1 2 1."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "5 4 -1 7 8",
        "expected_output": "23",
        "explanation": "All positive involved",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "-1 -2",
        "expected_output": "-1",
        "explanation": "Max is max single element if all negative",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Accumulate sum. If sum < 0, reset to 0.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 2,
        "hint_text": "Track global max.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "Handle all negative numbers case (max is single max element).",
        "hint_type": "common_mistake"
      },
      {
        "hint_level": 4,
        "hint_text": "One pass O(N).",
        "hint_type": "complexity"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Kadane's."
    }
  },
  {
    "problem_id": "Q127",
    "metadata": {
      "week": 5,
      "day": 3,
      "topic": "Dynamic Programming",
      "title": "Edit Distance",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 30,
      "category": "DSA",
      "company_tags": [
        "Google"
      ],
      "learning_outcomes": [
        "String Transformation"
      ]
    },
    "problem_statement": {
      "description": "Min operations (insert, delete, replace) to convert word1 to word2.",
      "constraints": [
        "Lengths <= 500"
      ],
      "input_format": "Word1, Word2.",
      "output_format": "Ops count.",
      "example": {
        "input": "horse, ros",
        "output": "3",
        "explanation": "h->r, remove r, remove e... or replace."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "intention, execution",
        "expected_output": "5",
        "explanation": "Complex",
        "category": "complex"
      },
      {
        "tc_id": "TC002",
        "input": "a, a",
        "expected_output": "0",
        "explanation": "Same",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "a, ",
        "expected_output": "1",
        "explanation": "Delete",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i][j] is dist between word1[0..i] and word2[0..j].",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "If chars match: dp[i-1][j-1].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Else: 1 + min(insert, delete, replace).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Base cases (empty strings).",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N)",
      "space_complexity": "O(M*N)",
      "optimal_approach": "2D DP."
    }
  },
  {
    "problem_id": "Q128",
    "metadata": {
      "week": 5,
      "day": 3,
      "topic": "Dynamic Programming",
      "title": "0/1 Knapsack Problem",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Classic"
      ],
      "learning_outcomes": [
        "Knapsack Pattern"
      ]
    },
    "problem_statement": {
      "description": "Max value with weight capacity W.",
      "constraints": [
        "N <= 100",
        "W <= 1000"
      ],
      "input_format": "Weights, Values, Capacity.",
      "output_format": "Max Value.",
      "example": {
        "input": "10 20 30, 60 100 120, 50",
        "output": "220",
        "explanation": "20+30 weights -> 100+120 val."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1, 1, 1",
        "expected_output": "1",
        "explanation": "Fits",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "10, 10, 5",
        "expected_output": "0",
        "explanation": "Doesn't fit",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "5 10, 10 20, 15",
        "expected_output": "30",
        "explanation": "Both fit",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i][w] = max value using first i items with capacity w.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Include item: val[i] + dp[i-1][w-wt[i]].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Exclude item: dp[i-1][w].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Take max of include/exclude.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N*W)",
      "space_complexity": "O(N*W)",
      "optimal_approach": "2D DP."
    }
  },
  {
    "problem_id": "Q129",
    "metadata": {
      "week": 5,
      "day": 3,
      "topic": "Dynamic Programming",
      "title": "Partition Equal Subset Sum",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon"
      ],
      "learning_outcomes": [
        "Subset Sum"
      ]
    },
    "problem_statement": {
      "description": "Determine if array can be partitioned into two subsets with equal sum.",
      "constraints": [
        "N <= 200",
        "Sum <= 20000"
      ],
      "input_format": "Array nums.",
      "output_format": "Boolean.",
      "example": {
        "input": "1 5 11 5",
        "output": "True",
        "explanation": "11 and 1+5+5."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2 3 5",
        "expected_output": "False",
        "explanation": "Odd sum",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 2",
        "expected_output": "True",
        "explanation": "Equal",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 5",
        "expected_output": "False",
        "explanation": "Sum 8, need 4. Impossible",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Total sum must be even. Goal is to find subset with sum = Total/2.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Subset Sum problem (variation of Knapsack).",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "dp[i] = true if sum i is achievable.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Iterate nums and update dp array from back to front.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N*Sum)",
      "space_complexity": "O(Sum)",
      "optimal_approach": "1D DP."
    }
  },
  {
    "problem_id": "Q130",
    "metadata": {
      "week": 5,
      "day": 3,
      "topic": "Dynamic Programming",
      "title": "Word Break",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Facebook",
        "Amazon"
      ],
      "learning_outcomes": [
        "String Dictionary"
      ]
    },
    "problem_statement": {
      "description": "Determined if string s can be segmented into dictionary words.",
      "constraints": [
        "Length <= 300",
        "Dict <= 1000"
      ],
      "input_format": "String s, List wordDict.",
      "output_format": "Boolean.",
      "example": {
        "input": "leetcode, [leet, code]",
        "output": "True",
        "explanation": "Segmented."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "applepenapple, [apple, pen]",
        "expected_output": "True",
        "explanation": "Used twice",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "catsandog, [cats, dog, sand, and, cat]",
        "expected_output": "False",
        "explanation": "Mismatch",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "a, [a]",
        "expected_output": "True",
        "explanation": "Single",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i] = true if s[0..i] is valid.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Check all split points j < i.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "If dp[j] is true AND s[j..i] in dict, then dp[i] is true.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Use Hash Set for dictionary lookups.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N^2)",
      "space_complexity": "O(N)",
      "optimal_approach": "DP."
    }
  },
  {
    "problem_id": "Q131",
    "metadata": {
      "week": 5,
      "day": 4,
      "topic": "Dynamic Programming",
      "title": "Maximum Product Subarray",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "LinkedIn"
      ],
      "learning_outcomes": [
        "Traverse both ends",
        "DP with Min/Max"
      ]
    },
    "problem_statement": {
      "description": "Find contiguous subarray with largest product.",
      "constraints": [
        "N <= 20000",
        "Integers"
      ],
      "input_format": "Array nums.",
      "output_format": "Max Product.",
      "example": {
        "input": "2 3 -2 4",
        "output": "6",
        "explanation": "2*3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "-2 0 -1",
        "expected_output": "0",
        "explanation": "Max is 0",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "-2",
        "expected_output": "-2",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "-2 3 -4",
        "expected_output": "24",
        "explanation": "-2*3*-4",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Product can become positive if two negatives multiplied.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Maintain curMax and curMin used to handle negatives.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If num < 0, swap curMax and curMin.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "curMax = max(num, curMax*num).",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Track Min/Max."
    }
  },
  {
    "problem_id": "Q132",
    "metadata": {
      "week": 5,
      "day": 4,
      "topic": "Greedy",
      "title": "Jump Game",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Apple"
      ],
      "learning_outcomes": [
        "Greedy"
      ]
    },
    "problem_statement": {
      "description": "Determine if you can reach the last index from the first.",
      "constraints": [
        "N <= 10^4"
      ],
      "input_format": "Array nums (max jump length).",
      "output_format": "True or False.",
      "example": {
        "input": "2 3 1 1 4",
        "output": "True",
        "explanation": "Reach 1 from 0, then 4."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 2 1 0 4",
        "expected_output": "False",
        "explanation": "Stuck at 0",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "True",
        "explanation": "Already at last",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2 0 0",
        "expected_output": "True",
        "explanation": "Jump over 0s",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Greedy: Maintain 'furthest' reachable index.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterate i. If i > furthest, return False.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Update furthest = max(furthest, i + nums[i]).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If furthest >= N-1, return True.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Greedy."
    }
  },
  {
    "problem_id": "Q133",
    "metadata": {
      "week": 5,
      "day": 4,
      "topic": "Greedy",
      "title": "Jump Game II",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google"
      ],
      "learning_outcomes": [
        "BFS via Greedy"
      ]
    },
    "problem_statement": {
      "description": "Min jumps to reach the last index. Assume you can always reach it.",
      "constraints": [
        "N <= 10^4"
      ],
      "input_format": "Array nums.",
      "output_format": "Min Jumps.",
      "example": {
        "input": "2 3 1 1 4",
        "output": "2",
        "explanation": "0 -> 1 -> 4."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 3 0 1 4",
        "expected_output": "2",
        "explanation": "Optimal",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "2 1",
        "expected_output": "1",
        "explanation": "One jump",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "0",
        "expected_output": "0",
        "explanation": "Start",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "BFS-like, but optimized.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Track current_end of jump and furthest reachable.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Iterate. Update furthest.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "When i reaches current_end, increment jumps, set current_end = furthest.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Greedy."
    }
  },
  {
    "problem_id": "Q134",
    "metadata": {
      "week": 5,
      "day": 4,
      "topic": "Greedy",
      "title": "Gas Station",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Diff Accumulation"
      ]
    },
    "problem_statement": {
      "description": "Find start index to travel around circular route once. Return -1 if impossible.",
      "constraints": [
        "N <= 10^5"
      ],
      "input_format": "Gas array, Cost array.",
      "output_format": "Start Index.",
      "example": {
        "input": "1 2 3 4 5, 3 4 5 1 2",
        "output": "3",
        "explanation": "Start at index 3 (val 4)."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 3 4, 3 4 3",
        "expected_output": "-1",
        "explanation": "Total gas < cost",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "5, 4",
        "expected_output": "0",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "3 1 1, 1 2 2",
        "expected_output": "0",
        "explanation": "Just enough",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "If total gas < total cost, return -1.",
        "hint_type": "edge_case"
      },
      {
        "hint_level": 2,
        "hint_text": "If meaningful start exists, it is unique.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "Iterate, add gas[i]-cost[i] to current_tank.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If current_tank < 0, reset start to i+1 and tank to 0.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Single Pass."
    }
  },
  {
    "problem_id": "Q135",
    "metadata": {
      "week": 5,
      "day": 5,
      "topic": "Bit Manipulation",
      "title": "Counting Bits",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Basic"
      ],
      "learning_outcomes": [
        "Bitwise DP"
      ]
    },
    "problem_statement": {
      "description": "Return array of number of 1s in binary representation for 0 to n.",
      "constraints": [
        "N <= 10^5"
      ],
      "input_format": "Integer n.",
      "output_format": "Array.",
      "example": {
        "input": "2",
        "output": "0 1 1",
        "explanation": "0(0), 1(1), 2(10)."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "5",
        "expected_output": "0 1 1 2 1 2",
        "explanation": "Standard",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0",
        "expected_output": "0",
        "explanation": "Zero",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1",
        "expected_output": "0 1",
        "explanation": "One",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "O(N log N) is trivial (popcount each).",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "DP: count[i] = count[i >> 1] + (i & 1).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "i & 1 checks if odd.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "i >> 1 is i/2.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "DP Bitwise."
    }
  },
  {
    "problem_id": "Q136",
    "metadata": {
      "week": 5,
      "day": 5,
      "topic": "Bit Manipulation",
      "title": "Single Number",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 10,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "Basic"
      ],
      "learning_outcomes": [
        "XOR Property"
      ]
    },
    "problem_statement": {
      "description": "Find the element that appears once (others appear twice).",
      "constraints": [
        "O(N) Time, O(1) Space"
      ],
      "input_format": "Array nums.",
      "output_format": "Value.",
      "example": {
        "input": "2 2 1",
        "output": "1",
        "explanation": "1 is unique."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4 1 2 1 2",
        "expected_output": "4",
        "explanation": "Pairs cancel",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "-1 -1 -2",
        "expected_output": "-2",
        "explanation": "Negative",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "XOR of same numbers is 0.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "XOR of x and 0 is x.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "XOR all elements.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Result is the single number.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "XOR."
    }
  },
  {
    "problem_id": "Q137",
    "metadata": {
      "week": 5,
      "day": 5,
      "topic": "Bit Manipulation",
      "title": "Missing Number",
      "difficulty_level": "EASY",
      "difficulty_stars": 1,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Sum Formula vs XOR"
      ]
    },
    "problem_statement": {
      "description": "Find missing number in range [0, n].",
      "constraints": [
        "N distinct numbers"
      ],
      "input_format": "Array nums.",
      "output_format": "Missing int.",
      "example": {
        "input": "3 0 1",
        "output": "2",
        "explanation": "2 missing from 0..3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0 1",
        "expected_output": "2",
        "explanation": "Range 0..2",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "9 6 4 2 3 5 7 0 1",
        "expected_output": "8",
        "explanation": "8 missing",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "0",
        "expected_output": "1",
        "explanation": "1 missing",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Sum formula: N*(N+1)/2 - sum(nums).",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "XOR approach: XOR all indices and values.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "XOR avoid overflow risks (though not issue with JS Number).",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Both are O(N).",
        "hint_type": "complexity"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "XOR or Sum."
    }
  },
  {
    "problem_id": "Q138",
    "metadata": {
      "week": 5,
      "day": 5,
      "topic": "Bit Manipulation",
      "title": "Reverse Bits",
      "difficulty_level": "EASY",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Apple"
      ],
      "learning_outcomes": [
        "Bit Shifting"
      ]
    },
    "problem_statement": {
      "description": "Reverse bits of a 32-bit unsigned integer.",
      "constraints": [
        "32 bit"
      ],
      "input_format": "Integer n.",
      "output_format": "Reversed Integer.",
      "example": {
        "input": "000...011 (3)",
        "output": "110...000 (3221225472)",
        "explanation": "Reversed."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "0",
        "expected_output": "0",
        "explanation": "Zero",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "4294967295",
        "expected_output": "4294967295",
        "explanation": "All 1s",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "43261596",
        "expected_output": "964176192",
        "explanation": "Random",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Loop 32 times.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Extract last bit: n & 1.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Shift result left, add extracted bit.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Shift n right.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1) (32 iterations)",
      "space_complexity": "O(1)",
      "optimal_approach": "Bitwise Shift."
    }
  },
  {
    "problem_id": "Q139",
    "metadata": {
      "week": 5,
      "day": 5,
      "topic": "Trie",
      "title": "Implement Trie (Prefix Tree)",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Microsoft",
        "Uber"
      ],
      "learning_outcomes": [
        "Trie Structure"
      ]
    },
    "problem_statement": {
      "description": "Implement Trie with insert, search, and startsWith.",
      "constraints": [
        "Lowercase english letters"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "insert apple, search apple, search app, startWith app",
        "output": "True, False, True",
        "explanation": "Results."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "insert a, search a",
        "expected_output": "True",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "insert app, search apple",
        "expected_output": "False",
        "explanation": "Prefix only",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "insert apple, startsWith z",
        "expected_output": "False",
        "explanation": "None",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Tree where each node has 26 children array.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Each node needs 'isEnd' boolean.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 3,
        "hint_text": "Insert: traverse/create nodes, mark end.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Search vs StartsWith: Search checks isEnd, StartsWith just checks existence.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(Length)",
      "space_complexity": "O(N * Length)",
      "optimal_approach": "Trie."
    }
  },
  {
    "problem_id": "Q140",
    "metadata": {
      "week": 5,
      "day": 5,
      "topic": "Trie",
      "title": "Longest Word in Dictionary",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 20,
      "category": "DSA",
      "company_tags": [
        "Goldman Sachs"
      ],
      "learning_outcomes": [
        "Trie Application"
      ]
    },
    "problem_statement": {
      "description": "Find longest word that can be built one character at a time (all prefixes must exist).",
      "constraints": [
        "Words <= 1000"
      ],
      "input_format": "Words array.",
      "output_format": "String.",
      "example": {
        "input": "w wo wor worl world",
        "output": "world",
        "explanation": "Sequence."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "a banana app appl ap apply apple",
        "expected_output": "apple",
        "explanation": "a->ap->app->appl->apple",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "abc",
        "expected_output": "",
        "explanation": "Prefixes missing",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "mo moa moab",
        "expected_output": "moab",
        "explanation": "Full chain",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Insert all into Trie.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "DFS on Trie.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Only traverse nodes where isEnd is true.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Return deepest string (lexicographically smallest on tie).",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(Sum of Lengths)",
      "space_complexity": "O(Sum of Lengths)",
      "optimal_approach": "Trie or Set."
    }
  },
  {
    "problem_id": "Q141",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Array",
      "title": "Trapping Rain Water",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 35,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Amazon",
        "Facebook"
      ],
      "learning_outcomes": [
        "Two Pointers",
        "Precomputation"
      ]
    },
    "problem_statement": {
      "description": "Calculate how much water can be trapped after raining based on elevation map.",
      "constraints": [
        "N <= 20000"
      ],
      "input_format": "Height array.",
      "output_format": "Water units.",
      "example": {
        "input": "0 1 0 2 1 0 1 3 2 1 2 1",
        "output": "6",
        "explanation": "Trapped water."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "4 2 0 3 2 5",
        "expected_output": "9",
        "explanation": "Calculated area",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 2 3",
        "expected_output": "0",
        "explanation": "Slope spills everything",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "2 0 2",
        "expected_output": "2",
        "explanation": "Bucket",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Water at index i is min(maxLeft, maxRight) - height[i].",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "O(N) Space: Precompute MaxLeft and MaxRight arrays.",
        "hint_type": "approach"
      },
      {
        "hint_level": 3,
        "hint_text": "O(1) Space: Use Two Pointers (left and right).",
        "hint_type": "optimal"
      },
      {
        "hint_level": 4,
        "hint_text": "Maintain leftMax and rightMax while moving pointers inward.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(1)",
      "optimal_approach": "Two Pointers."
    }
  },
  {
    "problem_id": "Q142",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Stack",
      "title": "Largest Rectangle in Histogram",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 35,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Monotonic Stack"
      ]
    },
    "problem_statement": {
      "description": "Find area of largest rectangle in histogram.",
      "constraints": [
        "Height <= 10^4"
      ],
      "input_format": "Heights array.",
      "output_format": "Max Area.",
      "example": {
        "input": "2 1 5 6 2 3",
        "output": "10",
        "explanation": "5 and 6 give 5*2=10."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 4",
        "expected_output": "4",
        "explanation": "Max single",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 1",
        "expected_output": "2",
        "explanation": "Combined",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "0",
        "expected_output": "0",
        "explanation": "Zero",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "For each bar, find 'Next Smaller Element' on left and right.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Width = RightIndex - LeftIndex - 1.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Use Monotonic Stack to find NSE boundaries in one pass.",
        "hint_type": "optimal"
      },
      {
        "hint_level": 4,
        "hint_text": "When popping, calculate area with popped height.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Monotonic Stack."
    }
  },
  {
    "problem_id": "Q143",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Array",
      "title": "Median of Two Sorted Arrays",
      "difficulty_level": "HARD",
      "difficulty_stars": 5,
      "estimated_time_minutes": 40,
      "category": "DSA",
      "company_tags": [
        "Google",
        "Amazon",
        "Apple"
      ],
      "learning_outcomes": [
        "Binary Search on Answer"
      ]
    },
    "problem_statement": {
      "description": "Find the median of two sorted arrays nums1 and nums2.",
      "constraints": [
        "O(log(m+n)) complexity"
      ],
      "input_format": "Nums1, Nums2.",
      "output_format": "Float Median.",
      "example": {
        "input": "1 3, 2",
        "output": "2.0",
        "explanation": "Merged: 1 2 3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1 2, 3 4",
        "expected_output": "2.5",
        "explanation": "Merged 1 2 3 4",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "0 0, 0 0",
        "expected_output": "0.0",
        "explanation": "Zeros",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "[], 1",
        "expected_output": "1.0",
        "explanation": "One empty",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Merging takes O(m+n). Too slow.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Binary Search on the smaller array for partition point.",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "Partition such that left half elements <= right half.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Complex boundary checks needed.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(log(min(M,N)))",
      "space_complexity": "O(1)",
      "optimal_approach": "Binary Search."
    }
  },
  {
    "problem_id": "Q144",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Intervals",
      "title": "Merge Intervals",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "LinkedIn"
      ],
      "learning_outcomes": [
        "Sorting",
        "Intervals"
      ]
    },
    "problem_statement": {
      "description": "Merge all overlapping intervals.",
      "constraints": [
        "N <= 10^4"
      ],
      "input_format": "List of intervals.",
      "output_format": "Merged list.",
      "example": {
        "input": "[1,3],[2,6],[8,10],[15,18]",
        "output": "[1,6],[8,10],[15,18]",
        "explanation": "Overlap."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "[1,4],[4,5]",
        "expected_output": "[1,5]",
        "explanation": "Touch",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "[1,4],[2,3]",
        "expected_output": "[1,4]",
        "explanation": "Consume",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "[1,2],[3,4]",
        "expected_output": "[1,2],[3,4]",
        "explanation": "Disjoint",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Sort intervals by start time.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Iterate. If current start <= previous end, merge.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Merge: End = max(prevEnd, currEnd).",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Else add new interval.",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N log N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Sort & Scan."
    }
  },
  {
    "problem_id": "Q145",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Design",
      "title": "LRU Cache",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 35,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Doubly Linked List",
        "Hash Map"
      ]
    },
    "problem_statement": {
      "description": "Design LRU Cache with get and put in O(1).",
      "constraints": [
        "Capacity"
      ],
      "input_format": "Commands.",
      "output_format": "Results.",
      "example": {
        "input": "put 1 1, put 2 2, get 1, put 3 3 (cap 2)",
        "output": "1, evict 2 in background",
        "explanation": "1 is accessed, 2 is LRU."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "put 1 1, get 1",
        "expected_output": "1",
        "explanation": "Basic",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "get 99",
        "expected_output": "-1",
        "explanation": "Miss",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "put 1 1, put 2 2, get 1, put 3 3, get 2",
        "expected_output": "-1",
        "explanation": "2 evicted",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Hash Map gives O(1) access.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Doubly Linked List allows O(1) move to head/tail.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 3,
        "hint_text": "Map stores key -> Node.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "On access, move Node to head (MRU). Remove tail on full.",
        "hint_type": "algorithm"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(1)",
      "space_complexity": "O(Capacity)",
      "optimal_approach": "HashMap + DLL."
    }
  },
  {
    "problem_id": "Q146",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Backtracking",
      "title": "N-Queens",
      "difficulty_level": "HARD",
      "difficulty_stars": 4,
      "estimated_time_minutes": 35,
      "category": "DSA",
      "company_tags": [
        "Classic"
      ],
      "learning_outcomes": [
        "Recursion"
      ]
    },
    "problem_statement": {
      "description": "Place N queens on NxN board such that no two attack each other.",
      "constraints": [
        "1 <= N <= 9"
      ],
      "input_format": "N.",
      "output_format": "List of Board configs.",
      "example": {
        "input": "4",
        "output": "2 solutions",
        "explanation": "Valid positions."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "1",
        "expected_output": "Q",
        "explanation": "Trivial",
        "category": "edge"
      },
      {
        "tc_id": "TC002",
        "input": "2",
        "expected_output": "[]",
        "explanation": "Impossible",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "4",
        "expected_output": "[...Q..], [...Q..]...",
        "explanation": "Solutions",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Place one queen per row.",
        "hint_type": "approach"
      },
      {
        "hint_level": 2,
        "hint_text": "Track attacked columns and diagonals.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Backtrack if no safe spot in current row.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Diagonals: row-col and row+col are constant.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N!)",
      "space_complexity": "O(N)",
      "optimal_approach": "Backtracking."
    }
  },
  {
    "problem_id": "Q147",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Dynamic Programming",
      "title": "Unique Paths",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 2,
      "estimated_time_minutes": 15,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Google"
      ],
      "learning_outcomes": [
        "Grid DP"
      ]
    },
    "problem_statement": {
      "description": "Ways to move from top-left to bottom-right (only down and right).",
      "constraints": [
        "M, N <= 100"
      ],
      "input_format": "M, N.",
      "output_format": "Count.",
      "example": {
        "input": "3, 7",
        "output": "28",
        "explanation": "Ways."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "3 2",
        "expected_output": "3",
        "explanation": "D-R-R, etc.",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1 1",
        "expected_output": "1",
        "explanation": "Start is End",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 10",
        "expected_output": "1",
        "explanation": "Straight line",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "dp[i][j] = ways to reach cell (i,j).",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "dp[i][j] = dp[i-1][j] + dp[i][j-1].",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "First row and col are all 1.",
        "hint_type": "implementation"
      },
      {
        "hint_level": 4,
        "hint_text": "Combinatorics: (M+N-2) choose (M-1).",
        "hint_type": "optimal"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N)",
      "space_complexity": "O(M*N)",
      "optimal_approach": "DP or Combinatorics."
    }
  },
  {
    "problem_id": "Q148",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Tree",
      "title": "Construct Binary Tree from Inorder and Postorder",
      "difficulty_level": "MEDIUM",
      "difficulty_stars": 3,
      "estimated_time_minutes": 25,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft"
      ],
      "learning_outcomes": [
        "Tree Build"
      ]
    },
    "problem_statement": {
      "description": "Reconstruct tree given inorder and postorder traversals.",
      "constraints": [
        "N <= 3000"
      ],
      "input_format": "Inorder, Postorder.",
      "output_format": "Root.",
      "example": {
        "input": "9 3 15 20 7, 9 15 7 20 3",
        "output": "3 9 20 null null 15 7",
        "explanation": "Root 3."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "2 1, 2 1",
        "expected_output": "1 2",
        "explanation": "Root-Left",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "1, 1",
        "expected_output": "1",
        "explanation": "Single",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "1 2 3, 3 2 1",
        "expected_output": "1 null 2 null 3",
        "explanation": "Skewed",
        "category": "basic"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Postorder last element is Root.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Find Root in Inorder to split Left and Right subtrees.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "Use Map for quick Inorder lookup.",
        "hint_type": "optimization"
      },
      {
        "hint_level": 4,
        "hint_text": "Recursively build Right then Left (stack order matters).",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(N)",
      "space_complexity": "O(N)",
      "optimal_approach": "Recursion with Map."
    }
  },
  {
    "problem_id": "Q149",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Trie",
      "title": "Word Search II",
      "difficulty_level": "HARD",
      "difficulty_stars": 5,
      "estimated_time_minutes": 40,
      "category": "DSA",
      "company_tags": [
        "Amazon",
        "Microsoft",
        "Uber"
      ],
      "learning_outcomes": [
        "Trie",
        "Backtracking"
      ]
    },
    "problem_statement": {
      "description": "Find all words from dictionary in 2D char board.",
      "constraints": [
        "12x12 Board, 30k Words"
      ],
      "input_format": "Board, Words.",
      "output_format": "List of found words.",
      "example": {
        "input": "o a a n\ne t a e\ni h k r\ni f l v, [oath, pea, eat, rain]",
        "output": "eat, oath",
        "explanation": "Found on board."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "a b, c d, [abdc]",
        "expected_output": "abdc",
        "explanation": "Snake",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "a a, [a]",
        "expected_output": "a",
        "explanation": "Single",
        "category": "basic"
      },
      {
        "tc_id": "TC003",
        "input": "a, [b]",
        "expected_output": "[]",
        "explanation": "None",
        "category": "edge"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Checking each word individually is too slow.",
        "hint_type": "trade_off"
      },
      {
        "hint_level": 2,
        "hint_text": "Put all words in a Trie.",
        "hint_type": "optimal"
      },
      {
        "hint_level": 3,
        "hint_text": "DFS from each cell simultaneous with Trie traversal.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "Pruning: Remove word from Trie after finding to avoid duplicates.",
        "hint_type": "optimization"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(M*N * 4^L)",
      "space_complexity": "O(TrieSize)",
      "optimal_approach": "Trie + DFS."
    }
  },
  {
    "problem_id": "Q150",
    "metadata": {
      "week": 5,
      "day": 6,
      "topic": "Backtracking",
      "title": "Sudoku Solver",
      "difficulty_level": "HARD",
      "difficulty_stars": 5,
      "estimated_time_minutes": 40,
      "category": "DSA",
      "company_tags": [
        "Classic"
      ],
      "learning_outcomes": [
        "Constraint Satisfaction"
      ]
    },
    "problem_statement": {
      "description": "Solve a Sudoku puzzle by filling empty cells.",
      "constraints": [
        "9x9 Grid"
      ],
      "input_format": "Board ('.' for empty).",
      "output_format": "Solved Board.",
      "example": {
        "input": "5 3 . . 7 ...",
        "output": "5 3 4 6 7 ...",
        "explanation": "Valid Sudoku."
      }
    },
    "test_cases": [
      {
        "tc_id": "TC001",
        "input": "Standard Puzzle",
        "expected_output": "Solved",
        "explanation": "Valid",
        "category": "basic"
      },
      {
        "tc_id": "TC002",
        "input": "One missing cell",
        "expected_output": "Filled",
        "explanation": "Simple",
        "category": "edge"
      },
      {
        "tc_id": "TC003",
        "input": "Hardest Sudoku",
        "expected_output": "Solved",
        "explanation": "Complex",
        "category": "complex"
      }
    ],
    "hints": [
      {
        "hint_level": 1,
        "hint_text": "Try 1-9 for each empty cell.",
        "hint_type": "conceptual"
      },
      {
        "hint_level": 2,
        "hint_text": "Check Row, Col, and 3x3 Box validity.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 3,
        "hint_text": "If valid, recurse to next empty cell.",
        "hint_type": "algorithm"
      },
      {
        "hint_level": 4,
        "hint_text": "If returns false, backtrack (reset cell to '.').",
        "hint_type": "implementation"
      }
    ],
    "complexity_guidance": {
      "time_complexity": "O(9^M) (Exp)",
      "space_complexity": "O(1) (Board)",
      "optimal_approach": "Backtracking."
    }
  }
]