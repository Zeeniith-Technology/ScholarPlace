[
    {
        "problem_id": "Q141",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Array",
            "title": "Trapping Rain Water",
            "difficulty_level": "HARD",
            "difficulty_stars": 4,
            "estimated_time_minutes": 35,
            "category": "DSA",
            "company_tags": [
                "Google",
                "Amazon",
                "Facebook"
            ],
            "learning_outcomes": [
                "Two Pointers",
                "Precomputation"
            ]
        },
        "problem_statement": {
            "description": "Calculate how much water can be trapped after raining based on elevation map.",
            "constraints": [
                "N <= 20000"
            ],
            "input_format": "Height array.",
            "output_format": "Water units.",
            "example": {
                "input": "0 1 0 2 1 0 1 3 2 1 2 1",
                "output": "6",
                "explanation": "Trapped water."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "4 2 0 3 2 5",
                "expected_output": "9",
                "explanation": "Calculated area",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1 2 3",
                "expected_output": "0",
                "explanation": "Slope spills everything",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "2 0 2",
                "expected_output": "2",
                "explanation": "Bucket",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Water at index i is min(maxLeft, maxRight) - height[i].",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "O(N) Space: Precompute MaxLeft and MaxRight arrays.",
                "hint_type": "approach"
            },
            {
                "hint_level": 3,
                "hint_text": "O(1) Space: Use Two Pointers (left and right).",
                "hint_type": "optimal"
            },
            {
                "hint_level": 4,
                "hint_text": "Maintain leftMax and rightMax while moving pointers inward.",
                "hint_type": "algorithm"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N)",
            "space_complexity": "O(1)",
            "optimal_approach": "Two Pointers."
        }
    },
    {
        "problem_id": "Q142",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Stack",
            "title": "Largest Rectangle in Histogram",
            "difficulty_level": "HARD",
            "difficulty_stars": 4,
            "estimated_time_minutes": 35,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Microsoft"
            ],
            "learning_outcomes": [
                "Monotonic Stack"
            ]
        },
        "problem_statement": {
            "description": "Find area of largest rectangle in histogram.",
            "constraints": [
                "Height <= 10^4"
            ],
            "input_format": "Heights array.",
            "output_format": "Max Area.",
            "example": {
                "input": "2 1 5 6 2 3",
                "output": "10",
                "explanation": "5 and 6 give 5*2=10."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "2 4",
                "expected_output": "4",
                "explanation": "Max single",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1 1",
                "expected_output": "2",
                "explanation": "Combined",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "0",
                "expected_output": "0",
                "explanation": "Zero",
                "category": "edge"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "For each bar, find 'Next Smaller Element' on left and right.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Width = RightIndex - LeftIndex - 1.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Use Monotonic Stack to find NSE boundaries in one pass.",
                "hint_type": "optimal"
            },
            {
                "hint_level": 4,
                "hint_text": "When popping, calculate area with popped height.",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N)",
            "space_complexity": "O(N)",
            "optimal_approach": "Monotonic Stack."
        }
    },
    {
        "problem_id": "Q143",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Array",
            "title": "Median of Two Sorted Arrays",
            "difficulty_level": "HARD",
            "difficulty_stars": 5,
            "estimated_time_minutes": 40,
            "category": "DSA",
            "company_tags": [
                "Google",
                "Amazon",
                "Apple"
            ],
            "learning_outcomes": [
                "Binary Search on Answer"
            ]
        },
        "problem_statement": {
            "description": "Find the median of two sorted arrays nums1 and nums2.",
            "constraints": [
                "O(log(m+n)) complexity"
            ],
            "input_format": "Nums1, Nums2.",
            "output_format": "Float Median.",
            "example": {
                "input": "1 3, 2",
                "output": "2.0",
                "explanation": "Merged: 1 2 3."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "1 2, 3 4",
                "expected_output": "2.5",
                "explanation": "Merged 1 2 3 4",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "0 0, 0 0",
                "expected_output": "0.0",
                "explanation": "Zeros",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "[], 1",
                "expected_output": "1.0",
                "explanation": "One empty",
                "category": "edge"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Merging takes O(m+n). Too slow.",
                "hint_type": "trade_off"
            },
            {
                "hint_level": 2,
                "hint_text": "Binary Search on the smaller array for partition point.",
                "hint_type": "optimal"
            },
            {
                "hint_level": 3,
                "hint_text": "Partition such that left half elements <= right half.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Complex boundary checks needed.",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(log(min(M,N)))",
            "space_complexity": "O(1)",
            "optimal_approach": "Binary Search."
        }
    },
    {
        "problem_id": "Q144",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Intervals",
            "title": "Merge Intervals",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Google",
                "LinkedIn"
            ],
            "learning_outcomes": [
                "Sorting",
                "Intervals"
            ]
        },
        "problem_statement": {
            "description": "Merge all overlapping intervals.",
            "constraints": [
                "N <= 10^4"
            ],
            "input_format": "List of intervals.",
            "output_format": "Merged list.",
            "example": {
                "input": "[1,3],[2,6],[8,10],[15,18]",
                "output": "[1,6],[8,10],[15,18]",
                "explanation": "Overlap."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "[1,4],[4,5]",
                "expected_output": "[1,5]",
                "explanation": "Touch",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "[1,4],[2,3]",
                "expected_output": "[1,4]",
                "explanation": "Consume",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "[1,2],[3,4]",
                "expected_output": "[1,2],[3,4]",
                "explanation": "Disjoint",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Sort intervals by start time.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Iterate. If current start <= previous end, merge.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Merge: End = max(prevEnd, currEnd).",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Else add new interval.",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N log N)",
            "space_complexity": "O(N)",
            "optimal_approach": "Sort & Scan."
        }
    },
    {
        "problem_id": "Q145",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Design",
            "title": "LRU Cache",
            "difficulty_level": "HARD",
            "difficulty_stars": 4,
            "estimated_time_minutes": 35,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Google",
                "Microsoft"
            ],
            "learning_outcomes": [
                "Doubly Linked List",
                "Hash Map"
            ]
        },
        "problem_statement": {
            "description": "Design LRU Cache with get and put in O(1).",
            "constraints": [
                "Capacity"
            ],
            "input_format": "Commands.",
            "output_format": "Results.",
            "example": {
                "input": "put 1 1, put 2 2, get 1, put 3 3 (cap 2)",
                "output": "1, evict 2 in background",
                "explanation": "1 is accessed, 2 is LRU."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "put 1 1, get 1",
                "expected_output": "1",
                "explanation": "Basic",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "get 99",
                "expected_output": "-1",
                "explanation": "Miss",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "put 1 1, put 2 2, get 1, put 3 3, get 2",
                "expected_output": "-1",
                "explanation": "2 evicted",
                "category": "complex"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Hash Map gives O(1) access.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Doubly Linked List allows O(1) move to head/tail.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 3,
                "hint_text": "Map stores key -> Node.",
                "hint_type": "implementation"
            },
            {
                "hint_level": 4,
                "hint_text": "On access, move Node to head (MRU). Remove tail on full.",
                "hint_type": "algorithm"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(1)",
            "space_complexity": "O(Capacity)",
            "optimal_approach": "HashMap + DLL."
        }
    },
    {
        "problem_id": "Q146",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Backtracking",
            "title": "N-Queens",
            "difficulty_level": "HARD",
            "difficulty_stars": 4,
            "estimated_time_minutes": 35,
            "category": "DSA",
            "company_tags": [
                "Classic"
            ],
            "learning_outcomes": [
                "Recursion"
            ]
        },
        "problem_statement": {
            "description": "Place N queens on NxN board such that no two attack each other.",
            "constraints": [
                "1 <= N <= 9"
            ],
            "input_format": "N.",
            "output_format": "List of Board configs.",
            "example": {
                "input": "4",
                "output": "2 solutions",
                "explanation": "Valid positions."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "1",
                "expected_output": "Q",
                "explanation": "Trivial",
                "category": "edge"
            },
            {
                "tc_id": "TC002",
                "input": "2",
                "expected_output": "[]",
                "explanation": "Impossible",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "4",
                "expected_output": "[...Q..], [...Q..]...",
                "explanation": "Solutions",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Place one queen per row.",
                "hint_type": "approach"
            },
            {
                "hint_level": 2,
                "hint_text": "Track attacked columns and diagonals.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Backtrack if no safe spot in current row.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Diagonals: row-col and row+col are constant.",
                "hint_type": "optimization"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N!)",
            "space_complexity": "O(N)",
            "optimal_approach": "Backtracking."
        }
    },
    {
        "problem_id": "Q147",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Dynamic Programming",
            "title": "Unique Paths",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 2,
            "estimated_time_minutes": 15,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Google"
            ],
            "learning_outcomes": [
                "Grid DP"
            ]
        },
        "problem_statement": {
            "description": "Ways to move from top-left to bottom-right (only down and right).",
            "constraints": [
                "M, N <= 100"
            ],
            "input_format": "M, N.",
            "output_format": "Count.",
            "example": {
                "input": "3, 7",
                "output": "28",
                "explanation": "Ways."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "3 2",
                "expected_output": "3",
                "explanation": "D-R-R, etc.",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1 1",
                "expected_output": "1",
                "explanation": "Start is End",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "1 10",
                "expected_output": "1",
                "explanation": "Straight line",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "dp[i][j] = ways to reach cell (i,j).",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "dp[i][j] = dp[i-1][j] + dp[i][j-1].",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "First row and col are all 1.",
                "hint_type": "implementation"
            },
            {
                "hint_level": 4,
                "hint_text": "Combinatorics: (M+N-2) choose (M-1).",
                "hint_type": "optimal"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(M*N)",
            "space_complexity": "O(M*N)",
            "optimal_approach": "DP or Combinatorics."
        }
    },
    {
        "problem_id": "Q148",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Tree",
            "title": "Construct Binary Tree from Inorder and Postorder",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Microsoft"
            ],
            "learning_outcomes": [
                "Tree Build"
            ]
        },
        "problem_statement": {
            "description": "Reconstruct tree given inorder and postorder traversals.",
            "constraints": [
                "N <= 3000"
            ],
            "input_format": "Inorder, Postorder.",
            "output_format": "Root.",
            "example": {
                "input": "9 3 15 20 7, 9 15 7 20 3",
                "output": "3 9 20 null null 15 7",
                "explanation": "Root 3."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "2 1, 2 1",
                "expected_output": "1 2",
                "explanation": "Root-Left",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1, 1",
                "expected_output": "1",
                "explanation": "Single",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "1 2 3, 3 2 1",
                "expected_output": "1 null 2 null 3",
                "explanation": "Skewed",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Postorder last element is Root.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Find Root in Inorder to split Left and Right subtrees.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Use Map for quick Inorder lookup.",
                "hint_type": "optimization"
            },
            {
                "hint_level": 4,
                "hint_text": "Recursively build Right then Left (stack order matters).",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N)",
            "space_complexity": "O(N)",
            "optimal_approach": "Recursion with Map."
        }
    },
    {
        "problem_id": "Q149",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Trie",
            "title": "Word Search II",
            "difficulty_level": "HARD",
            "difficulty_stars": 5,
            "estimated_time_minutes": 40,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Microsoft",
                "Uber"
            ],
            "learning_outcomes": [
                "Trie",
                "Backtracking"
            ]
        },
        "problem_statement": {
            "description": "Find all words from dictionary in 2D char board.",
            "constraints": [
                "12x12 Board, 30k Words"
            ],
            "input_format": "Board, Words.",
            "output_format": "List of found words.",
            "example": {
                "input": "o a a n\ne t a e\ni h k r\ni f l v, [oath, pea, eat, rain]",
                "output": "eat, oath",
                "explanation": "Found on board."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "a b, c d, [abdc]",
                "expected_output": "abdc",
                "explanation": "Snake",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "a a, [a]",
                "expected_output": "a",
                "explanation": "Single",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "a, [b]",
                "expected_output": "[]",
                "explanation": "None",
                "category": "edge"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Checking each word individually is too slow.",
                "hint_type": "trade_off"
            },
            {
                "hint_level": 2,
                "hint_text": "Put all words in a Trie.",
                "hint_type": "optimal"
            },
            {
                "hint_level": 3,
                "hint_text": "DFS from each cell simultaneous with Trie traversal.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Pruning: Remove word from Trie after finding to avoid duplicates.",
                "hint_type": "optimization"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(M*N * 4^L)",
            "space_complexity": "O(TrieSize)",
            "optimal_approach": "Trie + DFS."
        }
    },
    {
        "problem_id": "Q150",
        "metadata": {
            "week": 5,
            "day": 6,
            "topic": "Backtracking",
            "title": "Sudoku Solver",
            "difficulty_level": "HARD",
            "difficulty_stars": 5,
            "estimated_time_minutes": 40,
            "category": "DSA",
            "company_tags": [
                "Classic"
            ],
            "learning_outcomes": [
                "Constraint Satisfaction"
            ]
        },
        "problem_statement": {
            "description": "Solve a Sudoku puzzle by filling empty cells.",
            "constraints": [
                "9x9 Grid"
            ],
            "input_format": "Board ('.' for empty).",
            "output_format": "Solved Board.",
            "example": {
                "input": "5 3 . . 7 ...",
                "output": "5 3 4 6 7 ...",
                "explanation": "Valid Sudoku."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "Standard Puzzle",
                "expected_output": "Solved",
                "explanation": "Valid",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "One missing cell",
                "expected_output": "Filled",
                "explanation": "Simple",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "Hardest Sudoku",
                "expected_output": "Solved",
                "explanation": "Complex",
                "category": "complex"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Try 1-9 for each empty cell.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Check Row, Col, and 3x3 Box validity.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "If valid, recurse to next empty cell.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "If returns false, backtrack (reset cell to '.').",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(9^M) (Exp)",
            "space_complexity": "O(1) (Board)",
            "optimal_approach": "Backtracking."
        }
    }
]