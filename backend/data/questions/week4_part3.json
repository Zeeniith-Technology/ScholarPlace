[
    {
        "problem_id": "Q111",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Graph",
            "title": "Rotting Oranges",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Microsoft"
            ],
            "learning_outcomes": [
                "Multi-source BFS"
            ]
        },
        "problem_statement": {
            "description": "Grid with 0 (empty), 1 (fresh), 2 (rotten). Returns mins until all fresh rot. If impossible return -1.",
            "constraints": [
                "Grid <= 10x10"
            ],
            "input_format": "Grid.",
            "output_format": "Minutes.",
            "example": {
                "input": "2 1 1\n1 1 0\n0 1 1",
                "output": "4",
                "explanation": "Propagation."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "2 1 1\n0 1 1\n1 0 1",
                "expected_output": "-1",
                "explanation": "Isolated fresh orange",
                "category": "edge"
            },
            {
                "tc_id": "TC002",
                "input": "0 2",
                "expected_output": "0",
                "explanation": "No fresh oranges",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "2 1 1",
                "expected_output": "2",
                "explanation": "Simple",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "BFS starts from ALL rotten oranges simultaneously.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Enqueue all initial '2's.",
                "hint_type": "approach"
            },
            {
                "hint_level": 3,
                "hint_text": "Count fresh oranges initially.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Decrement fresh count as they rot. If fresh > 0 at end, return -1.",
                "hint_type": "algorithm"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N*M)",
            "space_complexity": "O(N*M)",
            "optimal_approach": "BFS."
        }
    },
    {
        "problem_id": "Q112",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Graph",
            "title": "01 Matrix",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Google"
            ],
            "learning_outcomes": [
                "BFS Distance"
            ]
        },
        "problem_statement": {
            "description": "Given a matrix, find distance of nearest 0 for each cell.",
            "constraints": [
                "10^4 cells"
            ],
            "input_format": "Matrix.",
            "output_format": "Distance Matrix.",
            "example": {
                "input": "0 0 0\n0 1 0\n1 1 1",
                "output": "0 0 0\n0 1 0\n1 2 1",
                "explanation": "Distances."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "0 0 0\n0 1 0\n0 0 0",
                "expected_output": "0 0 0\n0 1 0\n0 0 0",
                "explanation": "Surrounded",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1 1\n1 0",
                "expected_output": "2 1\n1 0",
                "explanation": "Corner",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "0",
                "expected_output": "0",
                "explanation": "Single",
                "category": "edge"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Start BFS from all 0s.",
                "hint_type": "approach"
            },
            {
                "hint_level": 2,
                "hint_text": "Initialize distances to Infinity for 1s, 0 for 0s.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Update neighbor if new dist < old dist.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "DP approach is also possible (two passes).",
                "hint_type": "optimization"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(M*N)",
            "space_complexity": "O(M*N)",
            "optimal_approach": "BFS."
        }
    },
    {
        "problem_id": "Q113",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Graph",
            "title": "Surrounded Regions",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Google"
            ],
            "learning_outcomes": [
                "Boundary Traversal"
            ]
        },
        "problem_statement": {
            "description": "Capture all 'O' surrounded by 'X'. (Flip O to X if not connected to boundary O).",
            "constraints": [
                "200x200"
            ],
            "input_format": "Board.",
            "output_format": "Captured Board.",
            "example": {
                "input": "X X X X\nX O O X\nX X O X\nX O X X",
                "output": "X X X X\nX X X X\nX X X X\nX O X X",
                "explanation": "Only boundary O survives."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "X X\nX X",
                "expected_output": "X X\nX X",
                "explanation": "No O",
                "category": "edge"
            },
            {
                "tc_id": "TC002",
                "input": "O O\nO O",
                "expected_output": "O O\nO O",
                "explanation": "All connected to boundary",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "X X X\nX O X\nX X X",
                "expected_output": "X X X\nX X X\nX X X",
                "explanation": "Captured",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Start from boundary 'O's.",
                "hint_type": "approach"
            },
            {
                "hint_level": 2,
                "hint_text": "Run DFS/BFS to mark 'Safe' regions (connected to boundary).",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "After traversal, flip remaining 'O' to 'X'.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Flip 'Safe' back to 'O'.",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(M*N)",
            "space_complexity": "O(M*N)",
            "optimal_approach": "Boundary DFS."
        }
    },
    {
        "problem_id": "Q114",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Graph",
            "title": "Clone Graph",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Facebook",
                "Google"
            ],
            "learning_outcomes": [
                "Deep Copy",
                "Hash Map"
            ]
        },
        "problem_statement": {
            "description": "Deep copy of a connected undirected graph.",
            "constraints": [
                "Ref nodes"
            ],
            "input_format": "Adjacency List.",
            "output_format": "Copied List.",
            "example": {
                "input": "1:[2,4], 2:[1,3], 3:[2,4], 4:[1,3]",
                "output": "Same structure, new objects.",
                "explanation": "Clone."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "1:[]",
                "expected_output": "1:[]",
                "explanation": "Single",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "",
                "expected_output": "",
                "explanation": "Empty",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "1:[2], 2:[1]",
                "expected_output": "Clone",
                "explanation": "Two nodes",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Use a Map<OldNode, NewNode> to track visited.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "DFS or BFS traversal.",
                "hint_type": "approach"
            },
            {
                "hint_level": 3,
                "hint_text": "If neighbor already in map, link to it.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Else create new node, add to map, and recurse.",
                "hint_type": "algorithm"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(V+E)",
            "space_complexity": "O(V)",
            "optimal_approach": "DFS with Map."
        }
    },
    {
        "problem_id": "Q115",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Graph",
            "title": "Course Schedule (Topological Sort)",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 25,
            "category": "DSA",
            "company_tags": [
                "Amazon"
            ],
            "learning_outcomes": [
                "Cycle Detection",
                "Topological Sort"
            ]
        },
        "problem_statement": {
            "description": "Can you finish all courses given prerequisites? (Detect cycle in directed graph).",
            "constraints": [
                "NumCourses <= 2000"
            ],
            "input_format": "NumCourses, Prerequisites.",
            "output_format": "True or False.",
            "example": {
                "input": "2, [[1,0]]",
                "output": "True",
                "explanation": "Take 0 then 1."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "2, [[1,0], [0,1]]",
                "expected_output": "False",
                "explanation": "Cycle",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1, []",
                "expected_output": "True",
                "explanation": "No prereq",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "3, [[1,0],[2,1]]",
                "expected_output": "True",
                "explanation": "Chain",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Construct Adjacency List.",
                "hint_type": "conceptual"
            },
            {
                "hint_level": 2,
                "hint_text": "Kahn's Algorithm (BFS) using Indegrees.",
                "hint_type": "approach"
            },
            {
                "hint_level": 3,
                "hint_text": "If queue becomes empty before counting all nodes, there is a cycle.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "DFS with 'recursion stack' check also works.",
                "hint_type": "approach"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(V+E)",
            "space_complexity": "O(V+E)",
            "optimal_approach": "Kahn's Algorithm."
        }
    },
    {
        "problem_id": "Q116",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Heap",
            "title": "Kth Largest Element in an Array",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 2,
            "estimated_time_minutes": 15,
            "category": "DSA",
            "company_tags": [
                "Facebook",
                "Amazon"
            ],
            "learning_outcomes": [
                "Priority Queue",
                "Quick Select"
            ]
        },
        "problem_statement": {
            "description": "Find Kth largest element.",
            "constraints": [
                "1 <= K <= N"
            ],
            "input_format": "Array, K.",
            "output_format": "Value.",
            "example": {
                "input": "3 2 1 5 6 4, 2",
                "output": "5",
                "explanation": "Sorted: 1 2 3 4 5 6. 2nd largest is 5."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "3 2 3 1 2 4 5 5 6, 4",
                "expected_output": "4",
                "explanation": "4th largest",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "1, 1",
                "expected_output": "1",
                "explanation": "Single",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "1 2, 2",
                "expected_output": "1",
                "explanation": "Min",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Sorting O(N log N) is trivial.",
                "hint_type": "trade_off"
            },
            {
                "hint_level": 2,
                "hint_text": "Use Min-Heap of size K. Root is Kth largest.",
                "hint_type": "optimal"
            },
            {
                "hint_level": 3,
                "hint_text": "Complexity O(N log K).",
                "hint_type": "complexity"
            },
            {
                "hint_level": 4,
                "hint_text": "QuickSelect is O(N) average.",
                "hint_type": "optimization"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N log K) or O(N)",
            "space_complexity": "O(K)",
            "optimal_approach": "Min-Heap."
        }
    },
    {
        "problem_id": "Q117",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Heap",
            "title": "Top K Frequent Words",
            "difficulty_level": "MEDIUM",
            "difficulty_stars": 3,
            "estimated_time_minutes": 20,
            "category": "DSA",
            "company_tags": [
                "Amazon",
                "Uber"
            ],
            "learning_outcomes": [
                "Custom Comparator"
            ]
        },
        "problem_statement": {
            "description": "Return K most frequent strings ordered by freq, then lexicographical.",
            "constraints": [
                "N strings"
            ],
            "input_format": "Array words, K.",
            "output_format": "List of strings.",
            "example": {
                "input": "i love leetcode i love coding, 2",
                "output": "i love",
                "explanation": "Highest freq."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "the day is sunny the the the sunny is is, 4",
                "expected_output": "the is sunny day",
                "explanation": "Order by count then alpha",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "a, 1",
                "expected_output": "a",
                "explanation": "Single",
                "category": "edge"
            },
            {
                "tc_id": "TC003",
                "input": "a aa, 1",
                "expected_output": "a",
                "explanation": "a before aa (alpha) if counts same (here counts diff)",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Count frequencies using Map.",
                "hint_type": "approach"
            },
            {
                "hint_level": 2,
                "hint_text": "Use Priority Queue with custom comparator.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Comparator: if freq equal, compare string order.",
                "hint_type": "implementation"
            },
            {
                "hint_level": 4,
                "hint_text": "Or bucket sort if N is small.",
                "hint_type": "optimization"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N log K)",
            "space_complexity": "O(N)",
            "optimal_approach": "Heap."
        }
    },
    {
        "problem_id": "Q118",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Heap",
            "title": "Find Median from Data Stream",
            "difficulty_level": "HARD",
            "difficulty_stars": 4,
            "estimated_time_minutes": 35,
            "category": "DSA",
            "company_tags": [
                "Google",
                "Amazon"
            ],
            "learning_outcomes": [
                "Two Heaps Pattern"
            ]
        },
        "problem_statement": {
            "description": "Design class to addNum and findMedian efficiently.",
            "constraints": [
                "Calls <= 10^4"
            ],
            "input_format": "Commands.",
            "output_format": "Results.",
            "example": {
                "input": "add 1, add 2, findMedian, add 3, findMedian",
                "output": "1.5, 2",
                "explanation": "Median of 1,2 is 1.5. Median of 1,2,3 is 2."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "add 1, find",
                "expected_output": "1",
                "explanation": "Single",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "add 10, add 20, add 30, add 40, find",
                "expected_output": "25",
                "explanation": "10 20 30 40 -> 25",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "add -1, add -2, find",
                "expected_output": "-1.5",
                "explanation": "Negative",
                "category": "edge"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Maintain sorted order? O(N) insertion.",
                "hint_type": "trade_off"
            },
            {
                "hint_level": 2,
                "hint_text": "Use Two Heaps: Max-Heap (left half) and Min-Heap (right half).",
                "hint_type": "optimal"
            },
            {
                "hint_level": 3,
                "hint_text": "Balance heaps so size diff is at most 1.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 4,
                "hint_text": "Median is top or avg of tops.",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(log N) add, O(1) find",
            "space_complexity": "O(N)",
            "optimal_approach": "Two Heaps."
        }
    },
    {
        "problem_id": "Q119",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Heap",
            "title": "Merge K Sorted Lists",
            "difficulty_level": "HARD",
            "difficulty_stars": 4,
            "estimated_time_minutes": 30,
            "category": "DSA",
            "company_tags": [
                "Facebook",
                "Microsoft"
            ],
            "learning_outcomes": [
                "Divide & Conquer",
                "Heap"
            ]
        },
        "problem_statement": {
            "description": "Merge k linked lists, each sorted, into one sorted list.",
            "constraints": [
                "K <= 10^4"
            ],
            "input_format": "Array of List Heads.",
            "output_format": "Merged Head.",
            "example": {
                "input": "1-4-5, 1-3-4, 2-6",
                "output": "1-1-2-3-4-4-5-6",
                "explanation": "Merged."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "[], []",
                "expected_output": "[]",
                "explanation": "Empty",
                "category": "edge"
            },
            {
                "tc_id": "TC002",
                "input": "1",
                "expected_output": "1",
                "explanation": "Single",
                "category": "basic"
            },
            {
                "tc_id": "TC003",
                "input": "1-2, 3-4",
                "expected_output": "1-2-3-4",
                "explanation": "Two lists",
                "category": "basic"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Min-Heap storing heads of all K lists.",
                "hint_type": "approach"
            },
            {
                "hint_level": 2,
                "hint_text": "Extract min, add next node of that list to heap.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Divide and Conquer: Pairwise merge.",
                "hint_type": "optimization"
            },
            {
                "hint_level": 4,
                "hint_text": "Pairwise merge is O(N log K) too.",
                "hint_type": "complexity"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(N log K)",
            "space_complexity": "O(K)",
            "optimal_approach": "Min-Heap."
        }
    },
    {
        "problem_id": "Q120",
        "metadata": {
            "week": 4,
            "day": 6,
            "topic": "Graph",
            "title": "Find the Town Judge",
            "difficulty_level": "EASY",
            "difficulty_stars": 1,
            "estimated_time_minutes": 10,
            "category": "DSA",
            "company_tags": [
                "Basic"
            ],
            "learning_outcomes": [
                "Degree Calculation"
            ]
        },
        "problem_statement": {
            "description": "Judge trusts nobody. Everybody trusting Judge. Find Judge index or -1.",
            "constraints": [
                "1 <= N <= 1000"
            ],
            "input_format": "N, Trust array.",
            "output_format": "Judge ID.",
            "example": {
                "input": "2, [[1,2]]",
                "output": "2",
                "explanation": "1 trusts 2."
            }
        },
        "test_cases": [
            {
                "tc_id": "TC001",
                "input": "3, [[1,3],[2,3]]",
                "expected_output": "3",
                "explanation": "Judge 3",
                "category": "basic"
            },
            {
                "tc_id": "TC002",
                "input": "3, [[1,3],[2,3],[3,1]]",
                "expected_output": "-1",
                "explanation": "3 trusts 1, not judge",
                "category": "complex"
            },
            {
                "tc_id": "TC003",
                "input": "1, []",
                "expected_output": "1",
                "explanation": "Single person is judge",
                "category": "edge"
            }
        ],
        "hints": [
            {
                "hint_level": 1,
                "hint_text": "Calculate indegree and outdegree.",
                "hint_type": "approach"
            },
            {
                "hint_level": 2,
                "hint_text": "Judge has Indegree N-1 and Outdegree 0.",
                "hint_type": "algorithm"
            },
            {
                "hint_level": 3,
                "hint_text": "Use array to store degrees.",
                "hint_type": "implementation"
            },
            {
                "hint_level": 4,
                "hint_text": "Iterate to check condition.",
                "hint_type": "implementation"
            }
        ],
        "complexity_guidance": {
            "time_complexity": "O(E+N)",
            "space_complexity": "O(N)",
            "optimal_approach": "Indegree Array."
        }
    }
]